<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020你好呀</title>
    <url>/2020/01/01/2020%E4%BD%A0%E5%A5%BD%E5%91%80/</url>
    <content><![CDATA[<h1 id="2020年的第一篇博客"><a href="#2020年的第一篇博客" class="headerlink" title="2020年的第一篇博客"></a>2020年的第一篇博客</h1><p>em…由于 <del><em>我的懒惰</em></del> 最近很忙，这段时间都没有更新我的博客。不过毕竟是20世纪20年代的第一天，我觉得仪式感很重的我总得做些啥吧。本来呢是想在微博上总结下2019年的，不过写了一点就不太好意思发了，可能我不太适合表达这些矫情的东西。想了想还是写在这里吧，反正这个博客也没几个人知道，更不会有人来看的（可能？）。</p>
<h2 id="2019流水账"><a href="#2019流水账" class="headerlink" title="2019流水账"></a>2019流水账</h2><p>仔细想想2019年我的心路历程还是挺跌宕起伏的，这是我毕业的第一年，我能感觉到周围的人还是把我当小孩子看，虽然讨厌这种感觉，不过我身上的稚气也确实没法压制住- -</p>
<h3 id="1月"><a href="#1月" class="headerlink" title="1月"></a>1月</h3><p>1月份太远了，竟然有些没印象了诶。不过我还记得19年的跨年夜晚上，我一直等着想看看谁会主动给我发条元旦快乐，最后啥也没有很尴尬（今年似乎也没好到哪去哈哈哈）。</p>
<p>对了，突然想起来还有一件事情，因为我的代码出了问题把公司测试环境后台所有数据全部删得一干二净。哈哈哈，当时脑子里第一个想法竟然是删库跑路？</p>
<h3 id="2月"><a href="#2月" class="headerlink" title="2月"></a>2月</h3><p>2月份过年了奥，过年前后我似乎都没有怎么请假，还和甘肃，重庆的同事疯狂调接口，这似乎也是一个令人难过的故事。现在的年好像都没什么年味了，只记得索然无趣的呆在家里一个礼拜，可能是自己长大了吧，不再对很多事物充满好奇，这或许也是一种悲哀。</p>
<h3 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h3><p>3月份去了一次杭州和2个舍友聚了一下。当时3个人在西湖上划着船，吹着风，哼着歌，我至今还记得那种感觉，毕业之后我似乎好久没那么放松开心了，当时想着一辈子就这样舒舒服服的也不错，不过生活还得往前走，该面对的还得面对。</p>
<h3 id="4月"><a href="#4月" class="headerlink" title="4月"></a>4月</h3><p>4月份开始了公司某个项目的代码重构编写设计。这个重构时间跨度很大，我原先对这个项目本身重构是报着很大热情，也全心全意的投入的，因为种种原因整个重构质量极差，让我挺难过的，我现在也常常在反思是否有更好的解决方法去应对当时的困难，不过4月份开始时还是蛮开心的啦。</p>
<p>同时4月份是我下定决心开始好好准备跳槽的时间，其实刚来公司的时候就已经有些计划开始慢慢看些技术相关的书和教程了，但是没有针对性的学习。记得当时花了99元买了一个盗版网课视频，从Mysql性能优化到Java虚拟机，每天下班无论多晚都会看上一两个小时，再做做笔记啥的。现在想想还蛮佩服当时自己的那个毅力的。</p>
<h3 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h3><p>5月除了照常每天学习外，似乎没什么让我印象深刻的事情了，好像吃了好多全家的冰激凌。当时还想着每吃一种冰激凌拍张照片，最后录一个vlog，只是后来觉得很无聊就放弃了。</p>
<h3 id="6月"><a href="#6月" class="headerlink" title="6月"></a>6月</h3><p>em…6月份初我记得一直嘴贱说自己想要出差，羡慕那些去重庆出差，哈尔滨出差的同事，很舒服。结果6月底就被安排去了云南…然后这一去就是40天…好像这件事情以后我这个无神论者竟然有点动摇了，难道冥冥之中自有天意？</p>
<h3 id="7月"><a href="#7月" class="headerlink" title="7月"></a>7月</h3><p>整个7月份基本上都是在云南度过的，讲讲这段时间的经历吧。刚去的时候其实很开心，现场客户那里基本上5点半就下班了也不要加班啥的，下班以后坐在宾馆的沙发里，喝着维他柠檬茶，听着焦迈奇的《我的名字》，再看着窗外的蓝天白云是真的舒服。周末的时候再一个人去滇池吹吹风或者去品尝一下玉溪各类小吃(怒推包浆豆腐，鳝丝米线！)，一切是那么美好。</p>
<p>不过呢，时间一长那种无聊，想找人沟通的感觉就开始强烈了起来，和我同行的两个同事，虽然知道人都还不错，但是实在是聊不到一起。一个年龄比我大2岁的研发，但是感觉思想比我老了20岁，每次见面真的是尬聊。还有一个年龄真的比我大20岁的售前，给人的感觉是那种“老奸巨猾”哈哈哈。他们相比我的确世故了很多，两人住一间房，发票开两间房的顶额，不像我老老实实实报实销- -可能是我幼稚吧，但是如果“成熟”是要变成这样，那我宁愿永远保持现在幼稚的样子。</p>
<h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><p>8月份已经回到上海了，8月初的时候就又去了一次杭州找舍友。这一次是我们4个时隔1年多再一次的聚齐，其实还蛮珍惜的。可惜的是黄大哥要去帮姐姐搬家，大家也就一起吃了顿饭稍微聊了聊以前的事情就分别了，没留张合影还挺遗憾的，不知道下一次4个聚齐是什么时候了，也不知道还能聚齐几次了吧。</p>
<p>哦对，8月份还有我的生日，我当时许下了找一份好工作的心愿…现在来看应该也算实现了？8月份的时候是我学习计划的末期，当时每天整理笔记，看面试题到2,3点，说实话真的挺累的，但是也是我提升最大的一个时期。</p>
<h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><p>9月份，可以算我2019年最难的一年了吧。当我把常考的题目复习的差不多了，我就开始投起了简历。起先我挺有自信的，在拉钩上精心挑选符合自己的岗位，我不是那种没有自知之明的人，我选的岗位都是我认为我能胜任的，也并没有去妄想挑战互联网第一梯队的企业。但是一天，两天，三天…一周后，我所有“精心”选择的岗位，没有一个有意向联系我。我至今不知道为什么，可能是因为我的简历，我的专业亦或是我的学历,但是我知道的是我当时真的慌了。我开始慌不择路，无论大公司小公司，什么样的要求都去投递一次，甚至还在网上各种尝试找人内推。这样做确实零星有公司联系我了，但是绝大多数都是外包公司以及就几人的小创业公司。那段时间我心中唯一的支撑塌了，我不明白为什么我付出了半年的努力，现今连一个面试的机会都拿不到。其实我是一个还蛮自负的人，但是那一刻我感到我的自负和自尊被这个社会按在地上反复摩擦。那段时间我下班了以后，常常一个人呆着怀疑人生，看看隔壁那栋LOGO明显的腾讯大楼自嘲，却又笑不出声。</p>
<p>不过值得庆幸的是，我也没有走到绝路。我收到了我现在这家公司的面试邀请，不得不说努力还是有用的。面试问的问题虽然不难，但是如果没有系统的去复习也绝对答不出来，我的表现似乎还算不错，HR也成天打电话问我的意向。这家公司确实不错，互联网医疗独角兽，薪资也开的还可以，但是说实话是低于我一开始的预期的。不过对于当时的我而言已经是黑暗中的一点光明了，我还是犹豫了很久，最后感觉他们的学习氛围很好可以提升很多以及舍友的劝说下，我坚定了自己的选择。现在呢我也没有后悔这个选择，反而很庆幸来到了这里。</p>
<p>这一章写的有点多，因为9月份确确实实对我的影响很大。经过这段时间，我突然感觉我自己成长了不少。如果说要总结这个月学到的话，那就是一句：<em>减少幻想却又保留希望，却又憧憬未来。</em></p>
<h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><p>10月初趁着十一去了趟北京和大学的好友们见见面。对我而言也是一个放松的时间，让我从9月份的紧绷着舒缓了下来。这期间真的吃了好多北京的特色，贼好吃的北京烤鸭，冰糖葫芦，炸酱面，铜锅涮肉以及喝了一口恶心一整晚的豆汁儿！（如果有人问我有没有吃过屎，我一定会说没有，但是我想我知道那个味道- -)一年多未见，大家似乎都没怎么变化，不过夜幕降临，一起喝酒时，才知道大家过的都不容易，后面喝的有点晕了只记得大家一起说了很多很多。咳咳，sbt太恶心了，吐的时候不仅吐到我身上，头都栽进马桶里了。这一次分别的时候，大家都没有哭，确实不能再像去年那样了。</p>
<p>北京回来后提出了离职，我导师说他知道我一定会提出离职的。说实话我挺敬佩他的，工作上对人对事都很认真，私下里确实一个很温柔的人。这家公司虽然有诸多令我不太喜欢的地方，但是这里的很多人都给我留下来很深刻的印象。或许多年之后，想起刚毕业就遇到了他们也会会心的笑吧。</p>
<h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><p>11月初去了麦田音乐节很开心，了解了一个宝藏棱镜乐队和一个宝藏小姐姐哈哈。棱镜的歌真的怒推，每首歌都超级好听！em..还有一个宝藏小姐姐，熟了之后发现她和外表看上去其实是很不一样的，她是一个内心很敏感细腻的人，会把所有问题都归咎在自己身上，但是她不知道她自己真的超级优秀，超级棒，希望她能走出这个困局吧。（突然想起来，这个小姐姐有一定概率会翻到我的博客，嗯，没错说的就是你，超级棒！）</p>
<p>之后的话就从原公司离职，无缝衔接来到了现在的这家公司。来到了这里我似乎打开了一个新世界的大门。我终于知道原先的研发流程是多么落后，这里的自动化集成测试，多环境部署，Apollo配置，中台战略，TDD,DDD等等等至今我都没有全部理解。最让我感动的是这里的研发氛围，可能是因为CTO是阿里出来的大手子，我觉得这是一家尊重程序员的企业，，更加注重培养程序员而不是一味的压榨。周围的人都很厉害，代码思路非常明确，不过我相信有一天我也可以做到！</p>
<h3 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h3><p>2019年的最后一个月似乎就是不停的在学习吧。目前在重构一个项目，很多东西我都不熟悉，压力说实话有点大。我感觉每次代码review的时候我都不是很有自信，思路也不是很清晰，我好怕自己会被大家瞧不起。em…故事还在继续，我也还在继续，未来谁知道呢？</p>
<h2 id="2020年？"><a href="#2020年？" class="headerlink" title="2020年？"></a>2020年？</h2><p>发现上面自己扯了好多流水账…打完这些字，回想下2019还挺精彩的。</p>
<p>今年跨年夜我也许下了一个心愿，但是..嘘..不能说，说出来的心愿就不能灵验了呢。</p>
<p>2020年和往常每年一样，我都有一个新年计划，不过我现在还在制定完善，这一次我得做一个可以量化的新年计划，等明年再来看看实现没，先在这里留个位置吧</p>
<h3 id="2020新年计划"><a href="#2020新年计划" class="headerlink" title="2020新年计划"></a>2020新年计划</h3><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>还是谢谢这个2019年吧，这一年我23岁，时间过得总是很快，我多想留在这个美好的年纪呀。未来的那个你，我想和你说，岁月很残酷，或许会把你对生活的热情浇灭，但是我希望你能记住23岁的那个你也曾拥有过炙热的心。</p>
]]></content>
      <categories>
        <category>乱七八糟</category>
      </categories>
  </entry>
  <entry>
    <title>从游戏设计到装饰器模式</title>
    <url>/2019/11/04/%E4%BB%8E%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E5%88%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>本博文碍于作者的学识与见解，难免会有疏漏错误之处，请谅解。<br><br>转载请注明出处: <a href="www.sshenzx.com">www.sshenzx.com</a> 谢谢~</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章主要想讲述一下设计模式中的装饰器模式。其实我是不太敢写关于设计模式的博文的，一是觉得用好设计模式本身就是需要大量经验作为基础，目前的我还欠些火候，二是觉得设计模式作为一种经验之谈，本来就很难描述清楚其精髓，网上查阅的博文大都只是扔了几个类图，放上代码就完事了，但作为读者真的是一脸懵逼…不过呢尽管这样，我也想尝试一下看看自己能不能解释清楚这个东西，也检查下自己究竟掌握了多少。这个系列的博文，我会尽量以一个读者的角度由浅入深的去了解装饰器模式的由来和使用。</p>
<a id="more"></a>

<h1 id="为什么要用装饰器模式？"><a href="#为什么要用装饰器模式？" class="headerlink" title="为什么要用装饰器模式？"></a>为什么要用装饰器模式？</h1><h2 id="从某款《传奇》网游的需求开始"><a href="#从某款《传奇》网游的需求开始" class="headerlink" title="从某款《传奇》网游的需求开始"></a>从某款《传奇》网游的需求开始</h2><p>我们今天的主角是一个叫Skrrr的程序员，任职于某著名游戏公司”贪玩红月”，最近公司在研发一款传奇类网游，自然请了众多大牌明星来代言哦。公司的业务是当用户被广告吸(e)引(xin)到之后，马上就能一键注册，瞬间创建自己的游戏人物。职业有战士，刺客，射手等等等，当然每个职业的初始属性是不同的。现在需要Skrrr同学，实现创建游戏角色的功能。</p>
<p>当然，这个简单的需求自然难不倒skrrr同学，它的设计如下：</p>
<p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/Decorator_1.jpg" class="lozad"></p>
<p>这真的很简单，每个职业继承于一个游戏角色的类就行了，以后如果要新增职业那就新建类就好啦，也方便扩展。于是，Skrrr同学看着自己满意的杰作开开心心的回家睡觉了。可是第二天，公司发现单单让用户创建几个职业根本赚不到钱呀，为了让用户体验到氪金的乐趣，让充钱的土豪在出生的时候就赢在起跑线上。于是推出了3种出生套餐，充了99元的用户，出生可以获得一把大剑，充了999的用户出生可以获得金丝软甲，充了9999的用户出生甚至可以获得上古神器——倚天剑……当然这些装备都是有属性加成的，不同的装备加的属性不一样。</p>
<p>这下Skrrr同学可头大了，没办法只能硬着头皮加班加点完成了这些功能，这一次它的设计如下：</p>
<p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/Decorator_2.jpg" class="lozad"></p>
<p>经过了一个晚上的战斗，Skrrr同学根据相应的职业创造出了各式各样的类，虽然很累，但是至少也是完成了，于是Skrrr同学看着自己似乎不是很满意的杰作疲惫的回家睡觉了。结果第二天，Skrrr同学终于发现事情并没有那么简单，噩梦才刚刚开始…原来公司的野心比自己想的还大，只要用户钱到位什么姿势它都会…公司推出了各式各样的出生套餐，什么匕首啊，屠龙刀啊等一堆装备。更夸张的是，当客户充满88888元后解锁多装备成就，左手屠龙刀右手倚天剑，身穿软猬甲，脚踩风火轮不是梦！当这些需求扔到Skrrr同学面前时，他终于崩溃了，增加一件装备就等于给每个职业加一个类，更何况时多件装备的组合,而且未来万一再新增职业，这工作量可是成几何倍的增长啊。</p>
<p>Skrrr同学这下真没辙了，哪怕加班到猝死，这种变态量的需求也应付不过来呀，那还有什么办法呢？</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>可以发现在上面的设计中，角色和装备这两个东西之间是完全耦合的，当一个装备进行了新增，那么相应的所有角色都要新增一个对应的类。同样的如果一个角色属性发生了修改，那么所有使用装备的该角色都要修改。这就导致了类非常多，同时很难扩展。这种方法其实违反了六大设计设计原则中的“开闭原则”。</p>
<blockquote>
<p>开闭原则: 一个软件实体（如类，模块和函数）应该对扩展开放，对修改关闭。</p>
</blockquote>
<p>其实在软件开发的过程中，改需求是非常频繁的一件事情。<strong>开闭原则</strong> 则是希望使用扩展的方式来进行改变，而不是修改现有代码的方式进行改变。这样的好处在于大大增加了系统的稳定性以及灵活性，降低代码劣化速度。</p>
<p>在Skrrr同学的设计里，如果任何一件装备的属性或者角色的属性改变了，那么所有有关它们的类全部都要修改，会导致后期的维护非常繁琐。而在设计之初如果能考虑到这一方面，使用合适的架构来设计类，就能使得角色与装备之间解耦，做到灵活配置。</p>
<p>当然对于整个软件架构完完全全做到开闭原则是几乎是不可能的，因为想要遵循开闭原则通常要引入一些新的抽象层次，增加代码的复杂度。而我们所要做的应该是在软件规划的时候就提前找到最容易变化的地方，针对性的应用开闭原则。</p>
<p>以上写了这么多其实就是想说明Skrrr同学遇到的这种困难完全是因为它违反了”开闭原则”而导致的。那么如何解决这个问题，或者说如何让代码遵循“开闭原则”，就可以用到我们今天所要讲的<strong>装饰器模式</strong>了</p>
<h1 id="装饰器模式的使用"><a href="#装饰器模式的使用" class="headerlink" title="装饰器模式的使用"></a>装饰器模式的使用</h1><blockquote>
<p>装饰器模式的定义：动态地将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择</p>
</blockquote>
<p>其实装饰器模式挺好理解的，顾名思义，就是通过对一个类或者说对象进行装饰，而使得不修改这个类就能达到动态扩展的目的。这种模式会创建一个装饰类，用来包装原有的类，同时该装饰类也同样会保持原有类的类型。它的类图如下：</p>
<p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/Decorator_3.jpg" class="lozad"></p>
<p>从类图中可以发现一个很特别的点，装饰器类继承了我们被装饰类的同时又持有了被装饰的类。我个人觉得这就是装饰器模式的精髓，利用了组合+继承的方式实现动态扩展。通过继承的方法继承了被装饰类的类型，但是并没有继承被装饰类的行为，而是通过装饰者和组件组合的方式，重新定义了类的行为。</p>
<h2 id="利用装饰器实现《传奇》网游的新需求"><a href="#利用装饰器实现《传奇》网游的新需求" class="headerlink" title="利用装饰器实现《传奇》网游的新需求"></a>利用装饰器实现《传奇》网游的新需求</h2><p>Skrrr同学认认真真的了解了装饰器模式后，终于顿悟了。在一个晚上的努力后，这一次它的新设计如下：</p>
<p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/Decorator_4.jpg" class="lozad"></p>
<p>使用了装饰器模式之后，装备和角色完全解耦，新增一件装备就直接扩展新的类即可，再也不用处理一堆类了。不仅如此，面对同时要求携带多个装备的需求也相应解决。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li><p>游戏角色的基类AbstractCharacter(被装饰的类)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCharacter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生命值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer hp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 攻击力</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer atk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 防御力</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer def;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 速度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer spd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 职业名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 人物描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>游戏装备类AbstractEquipmentDecorator(装饰类)：</p>
</li>
</ul>
<p>在这里可以看到在装备类中我们要求继承的基类中所有的方法都设置为了Abstract必须要重写。还记得上文所提到的么，装饰类继承被装饰类是为了继承被装饰类的类型，而不是被装饰类的行为。所有的行为都是通过组合的方式去重新定义行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEquipmentDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractCharacter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法必须重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title">getHp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法必须重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title">getAtk</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法必须重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title">getDef</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法必须重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title">getSpd</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法必须重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">describe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>骑士(游戏角色实现类):</li>
</ul>
<p>定义了最简的初始属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Knight</span> <span class="keyword">extends</span> <span class="title">AbstractCharacter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Knight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setHp(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">this</span>.setAtk(<span class="number">45</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDef(<span class="number">70</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSpd(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">this</span>.setName(<span class="string">"骑士"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>大剑(游戏装备实现类)</li>
</ul>
<p>通过构造方法传参,我们允许让大剑装饰类允许引用一个角色类，这个角色类不一定就是战士/刺客这种角色实现类哦，还有可能也是一件装备(甚至可以用无数个包装类包装一个组件)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sword</span> <span class="keyword">extends</span> <span class="title">AbstractEquipmentDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过组合的方式持有了游戏角色基类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AbstractCharacter character;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sword</span><span class="params">(AbstractCharacter character)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.character = character;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getHp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> character.getHp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在原有角色基础上攻击力+30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAtk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> character.getAtk() + <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在原有角色基础上防御力+5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> character.getDef() + <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSpd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> character.getSpd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将原有角色 携带的所有都打印出来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> character.describe() + <span class="string">" 装备了一把大剑"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><ul>
<li><p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个持剑带铠甲的刺客</span></span><br><span class="line">        AbstractCharacter assassinWithSwordAndArmor = <span class="keyword">new</span> Assassin();</span><br><span class="line">        assassinWithSwordAndArmor = <span class="keyword">new</span> Sword(assassinWithSwordAndArmor);</span><br><span class="line">        assassinWithSwordAndArmor = <span class="keyword">new</span> Armor(assassinWithSwordAndArmor);</span><br><span class="line"></span><br><span class="line">        System.out.println(assassinWithSwordAndArmor.describe());</span><br><span class="line">        System.out.println(<span class="string">" 攻击力:"</span> + assassinWithSwordAndArmor.getAtk());</span><br><span class="line">        System.out.println(<span class="string">" 防御力:"</span> + assassinWithSwordAndArmor.getDef());</span><br><span class="line">        System.out.println(<span class="string">" 生命值:"</span> + assassinWithSwordAndArmor.getHp());</span><br><span class="line">        System.out.println(<span class="string">" 速度:"</span> + assassinWithSwordAndArmor.getSpd());</span><br><span class="line">        System.out.println(<span class="string">"==================================="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个双剑骑士</span></span><br><span class="line">        AbstractCharacter doubleSwordKnight = <span class="keyword">new</span> Knight();</span><br><span class="line">        doubleSwordKnight = <span class="keyword">new</span> Sword(doubleSwordKnight);</span><br><span class="line">        doubleSwordKnight = <span class="keyword">new</span> Sword(doubleSwordKnight);</span><br><span class="line"></span><br><span class="line">        System.out.println(doubleSwordKnight.describe());</span><br><span class="line">        System.out.println(<span class="string">" 攻击力:"</span> + doubleSwordKnight.getAtk());</span><br><span class="line">        System.out.println(<span class="string">" 防御力:"</span> + doubleSwordKnight.getDef());</span><br><span class="line">        System.out.println(<span class="string">" 生命值:"</span> + doubleSwordKnight.getHp());</span><br><span class="line">        System.out.println(<span class="string">" 速度:"</span> + doubleSwordKnight.getSpd());</span><br><span class="line">        System.out.println(<span class="string">"=================================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">刺客 装备了一把大剑 装备了一具铠甲</span><br><span class="line"> 攻击力:110</span><br><span class="line"> 防御力:85</span><br><span class="line"> 生命值:70</span><br><span class="line"> 速度:50</span><br><span class="line">===================================</span><br><span class="line">骑士 装备了一把大剑 装备了一把大剑</span><br><span class="line"> 攻击力:105</span><br><span class="line"> 防御力:80</span><br><span class="line"> 生命值:80</span><br><span class="line"> 速度:30</span><br><span class="line">==================================</span><br></pre></td></tr></table></figure>

<p>至此Skrrr同学完全实现了动态拓展游戏角色和装备。无论是装备还是角色再如何修改与变动，都只要专注于修改它们本身即可。这种方式看起来似乎万无一失，但是不是真的完美呢？</p>
<h1 id="装饰器模式仍存在的问题"><a href="#装饰器模式仍存在的问题" class="headerlink" title="装饰器模式仍存在的问题"></a>装饰器模式仍存在的问题</h1><p>以上大致介绍了装饰器模式的使用方式。我们可以了解到装饰器模式最大的好处在于使得装饰对象与被装饰对象解耦，使得被修饰的类可以动态拓展。并且他完全符合开闭原则，解决了以前使用继承而导致的类爆炸问题。</p>
<p>当然所有设计模式都不是完美的，它只适用于特定的情况。装饰器模式自然也有些弊端:</p>
<ol>
<li>这种多层修饰会导致类的层次比较复杂会衍生出许多包装类，因此如果只是简单的几个类的扩展的话，完全没必要使用装饰器模式。</li>
<li>可以动态装饰，但是不能动态的撤销装饰。在上述例子中，虽然每个角色可以动态携带各种装备，但是一旦人物创建完成后，未来想要把某件装备换下就做不到了（想要解决这个问题,可以采用策略模式，未来应该会有介绍）。</li>
</ol>
<p>因此不止是装饰器模式，任何设计模式在使用前需要仔细考量需求，判断设计模式是否真的符合当前情况。在合适的地方使用合适的设计模式的确可以大大优化系统架构，但是如果滥用设计模式的话反而会导致系统更加的复杂难懂。当然这种判断力自然是需要经验的累积的，只有踩过了足够的坑才知道什么才是最适合的。</p>
<h1 id="JDK中的装饰器模式"><a href="#JDK中的装饰器模式" class="headerlink" title="JDK中的装饰器模式"></a>JDK中的装饰器模式</h1><p>JDK中其实也运用了许许多多精巧的设计模式。装饰器模式自然也有，最经典的就是Java的IO流。IO流中分为了节点流与处理流,节点流如：FileInputStream,ByteArrayInputStream。处理流如：BufferedInputStream,DataInputStream。其中节点流其实就是被装饰的对象，而处理流则是基于节点流的装饰对象。其类图如下：</p>
<p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/Decorator_5.jpg" class="lozad"></p>
<p>可以看到所有的处理流类都继承于FilterInputStream的抽象包装类，类似于例子中的装备类。而所有节点流都直接继承InputStream的基类，类似于例子中的角色类。当然正是应用了装饰器模式，所以导致Java.io包的各种流特别多，造成了一定的复杂度，当然为了好的扩展性，这种设计模式是利大于弊的。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天所介绍的是设计模式之——装饰器模式。洗完后其实感觉这篇文章思路并不是特别清晰,同时也碍于自己的水平设计模式这一块的分析并不是特别到位，以后说不定还会有所修改吧。那简单介绍下我个人认为装饰器模式的几个要点：</p>
<ol>
<li>装饰器模式通过继承+组合的方式在动态拓展类的行为的同时，仍保留了原有类的类型。</li>
<li>可以用无数个装饰类包装一个组件。</li>
<li>装饰器模式符合“开闭原则”,即对拓展开放，对修改关闭。</li>
<li>不要滥用装饰器模式，使用装饰器模式会产生许多小的包装类，需要合理选择。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《HeadFirst设计模式(中文版)》</p>
]]></content>
      <categories>
        <category>死磕设计模式系列</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>探究JDK1.8中HashMap的实现原理</title>
    <url>/2019/10/19/%E6%8E%A2%E7%A9%B6JDK8%E4%B8%ADHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>本博文碍于作者的学识与见解，难免会有疏漏错误之处，请谅解。<br><br>转载请注明出处: <a href="www.sshenzx.com">www.sshenzx.com</a> 谢谢~</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总结了一个月的面试经验(其实也就3场面试…)，HashMap这个点基本上是必被问到的，因此想再看一遍HashMap的源码，对其底层加深一下印象。作为我的第一篇正式博客同时也知道没几个人会看这个博客，我就不说什么欢迎指正的客套话了，爱咋咋地。</p>
<p>(注：本文所述的HashMap以及代码都是基于JDK1.8的，与之前的版本区别较大，需要注意)</p>
<h1 id="什么是HashMap？"><a href="#什么是HashMap？" class="headerlink" title="什么是HashMap？"></a>什么是HashMap？</h1><p>HashMap本质当然是Map，是一个存储Key-Value键值对的数据结构。由于它会对每个Key进行hash运算存储其定位，因此它的查询以及插入效率非常高。在理想状态下时间复杂度为O(1)，最差情况下时间复杂度为O(n)。但同时它也是线程不安全的，如果想要使用线程安全的HashMap建议使用ConcurrentHashMap。</p>
<a id="more"></a>
<h1 id="HashMap的内部结构"><a href="#HashMap的内部结构" class="headerlink" title="HashMap的内部结构"></a>HashMap的内部结构</h1><p>HashMap的本质是一个链表+数组的数据结构。（JDK1.8还增加了红黑树的结构） 其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//主要存储数据的对象 table</span></span><br><span class="line">  <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Node类</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//算出的hash值，用来定义数组索引的位置</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="comment">//key值</span></span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  <span class="comment">//value值</span></span><br><span class="line">  V value;</span><br><span class="line">  <span class="comment">//指向下一个Node对象</span></span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//get set方法</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码我们可以看到Node类作为HashMap的静态内部类，本身实现了Map.Entry,它是真正用来存储键值对的，同时他也是一个链表。而HashMap内部维护了一个Node数组名为table的变量，也被称为哈希桶，是HashMap的核心，各项操作都围绕它展开。他的整个内部图如下：</p>
<p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/HashMap_5.jpg" class="lozad"></p>
<p>HashMap还有几个比较重要的成员变量，在了解其原理之前我们必须先认识他们。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//HashMap目前保存键值对数量(也就是大小)</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录HashMap内部结构发生变化的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所能容纳的键值对极限</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p><strong>size</strong><br>和其他容器的size一样，代表着目前HashMap存放的键值对数量</p>
<p><strong>threshold</strong><br>代表HashMap能容纳键值对的个数极限，如果一旦超过这个极限HashMap就会进行相应的扩容。</p>
<p><strong>loadFactor</strong><br>是负载因子，它也会影响到threhold的变化：threshold = length * loadFactor 。这里的<br><strong>length</strong><br>也就是table数组的大小 ，默认值给的是16，值得注意的是它的值永远是2的n次方，这是HashMap做的一个优化点，也是面试经常问的，后续会讲明其原因。从上面这个公式可以看出，loadFactor越小，threshold也会越小，会导致扩容频率变高，容易造成空间浪费。loadFactor越大，threshold也会越大，扩容频率变小，但会增大Hash冲突的机率，耗时更久(这一块目前不理解没关系，后面会讲解)。因此loadFactor的大小填写，是需要我们再时间复杂度与空间复杂度之间权衡的，系统默认值给的是0.75，符合大部分情况，一般不建议修改。</p>
<p><strong>modCount</strong><br>字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对时modCount会加一，但是某个key对应的value值被覆盖不属于结构变化所以modCount不会变化。</p>
<h1 id="HashMap-源码解析"><a href="#HashMap-源码解析" class="headerlink" title="HashMap 源码解析"></a>HashMap 源码解析</h1><p>对HashMap有一定的了解后，我们终于可以开始手撕源码啦。我们首先就从put方法进入开始看源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  key值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果key对应的value已经存在，是否覆盖value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为false表示处于创建状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回key对应的上一个value数据，如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">                 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到put方法本身内部又调用了putVal，它有五个入参，在注解上我也已经写了，<br>它们分别代表：</p>
<ol>
<li>hash：key的hash值</li>
<li>key： key值</li>
<li>value: value值</li>
<li>onlyIfAbsent：如果key对应的value已经存在，是否覆盖value值</li>
<li>evict：如果为false表示处于创建状态，仅仅为LinkedHashMap方便排序操作，HashMap中可以忽略</li>
</ol>
<p>针对于onlyIfAbsent为true，很明显我们的HashMap如果key已经对应存在对应value映射，在put时会覆盖掉原来的值，想不覆盖的话可以调用putIfAbsent()方法。</p>
<p>有一个重点其实是在方法hash(key)上，这个方法计算出了key的hash值，他是HashMap的精华所在，也是面试中常问的一个考点。接下来我们将重点说明下这个方法以及如何使用这个hash值</p>
<h2 id="hash-方法以及确定哈希桶数组索引位置"><a href="#hash-方法以及确定哈希桶数组索引位置" class="headerlink" title="hash()方法以及确定哈希桶数组索引位置"></a>hash()方法以及确定哈希桶数组索引位置</h2><p>hash()方法其实顾名思义就是用来获取key的hash的一个hash值的,但是HashMap里的hash()方法似乎与一般的直接key.hashCode()不太一样，我们先看看它到底是什么样的神奇操作。<br>其源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>歪果仁的代码追求精简，虽然就两行，但是看起来还是蛮恶心的，但是还是可以看出来如果key为空，那么hash值就默认问0，这也就说明HashMap的key是可以为空的，而我们也知道HashTable的key不能为空。如果不为空则会执行后面一长串，这一长串可以分步骤看</p>
<ol>
<li>h = key.hashCode() 获取了key的hashCode值</li>
<li>h^h&gt;&gt;&gt;16   将hashCode的值异或他的高16位获取到hash值</li>
</ol>
<p>我们知道hashCode本身是一个32位的int类型，进行这样的操作就等于将hashCode的高16位异或它的低16位得到一个新的hash值。</p>
<p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/HashMap_1.jpg" class="lozad"></p>
<p>但是拿到这样一个hash值的作用是什么呢？我们可以先想一下如何利用key的hash值确定每个key的哈希桶索引位置而且还需要尽量均衡。第一个想到的当然是用hash值对哈希桶的长度(length)进行取模的操作。(当然我本人是连这种方式都想不到的= =)即:</p>
<p> <strong>index = hash % length</strong></p>
<p>这种方式可以用随机的hash值算出随机的索引并且分配也尽量均匀。没错！!HashMap也是这么想的。但是这种取模运算本身是对CPU运算开销比较大的，为了优化速度，HashMap采取了更优雅的方式，在putVal的核心代码里可以看到这么一段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*为了方便理解,代码有改动+精简,但是整体思路没变</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;            </span><br><span class="line">                    <span class="comment">//table就是HashMap的table即哈希桶</span></span><br><span class="line">                    Node&lt;K,V&gt;[] tab = table;    </span><br><span class="line">                    <span class="comment">//哈希桶的长度</span></span><br><span class="line">                    <span class="keyword">int</span> length = tab.length;  </span><br><span class="line">                    <span class="comment">//确定索引的位置</span></span><br><span class="line">                    <span class="keyword">int</span> index = (length-<span class="number">1</span>) &amp; hash;       </span><br><span class="line">                    <span class="comment">//索引的值</span></span><br><span class="line">                    Node&lt;K,V&gt; p = tab[index];</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到HashMap采用了hash值”与”length-1的方式来确定索引位置。即：</p>
<p> <strong>index = hash &amp; length-1</strong></p>
<p>还记得之前我们说过hashTable的length总是2的n次方吗？这个是故意为了加快取模运算而设计的。当length的长度为2的n次方时hash值对length取模或者”与”上length-1得到的效果是一样的，但是”与”操作相比取模速度能快很多。<br>而之所以hash值要用拿hashcode的高16位异或低16位的原因根据官方的解释是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/HashMap_2.jpg" class="lozad"></p>
<p><font color="red"><b>小Tips:</b></font></p>
<p>hash()方法中的高16位异或16位的计算方式，是在JDK1.8之后才加上的，在JDK1.7及之前的版本里是indexFor()方法，直接用hashCode&amp;length-1计算出索引位置。如果面试官有问HashMap的JDK1.7与JDK1.8的区别可不要忘记说了哦<br></p>
<h2 id="putVal-方法解析"><a href="#putVal-方法解析" class="headerlink" title="putVal()方法解析"></a>putVal()方法解析</h2><p>了解了如何确定哈希桶的索引地址后我们终于可以来看看核心操作方法putVal了，不多说直接撕源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  key值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果key对应的value已经存在，是否覆盖value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为false表示处于创建状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回key对应的上一个value数据，如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果发现哈希桶为空或者长度为0，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定哈希桶的索引位置，如果里面目前没有数据，则直接插入新Node进去</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有数据，即发生hash冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果新插入数据的key与发生冲突的Node的key值相同，则记录下来</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果冲突的Node已经是红黑树结构了，则调用树的插入方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是链表则开始遍历链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//整个链表遍历完成后仍未发现key值相同的数据,则在链表结尾插入数据</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//插入数据后，发现链表数量已经到达一定长度后链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//发现新插入的key值与链表已存在的数据key值相同，则记录下来</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有替换原有数据，则将新值替换旧值并返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">//如果onlyIfAbsent为true就不替换了</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//方便linkedHashMap排序操作，HashMap里可无视</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//modCount+1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果新加如元素后发现键值对超过所能容纳的键值对极限则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();        </span><br><span class="line">      <span class="comment">//方便linkedHashMap排序操作，HashMap里可无视    </span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据代码我们可以大致理出putVal的操作流程</p>
<ol>
<li>判断哈希桶大小，如果为空则进行第一次的扩容</li>
<li>计算索引位置index，如果哈希桶索引位置table[index]没有数据则插入数据新数据，并判断键值对数量是否超过了threshHold，超过了则进行扩容。</li>
<li>如果table[index]有数据即发生hash冲突，判断table[index]的key值是否与插入的数据相同，如果相同则使用新的数据覆盖原有数据并返回原有数据，否则继续。</li>
<li>判断table[index]是否为为红黑树，如果是的话则直接在红黑树中插入数据，否则则继续</li>
<li>遍历链表tabe[i],如果存在key相等的数据则覆盖原有数据，并返回原有数据。如果不存在key相等的数据则在链表末尾插入新数据，同时判断链表长度是否到达可以转换红黑树的标准(默认长度为8)，到达的话则进行转换。</li>
</ol>
<p>具体流程如图如下所示：</p>
<p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/HashMap_3.jpg" class="lozad"></p>
<p><font color="red"><b>小Tips:</b></font></p>
<p>链表长度大于8转换成红黑树的操作是在JDK1.8中新加的，目的是当出现大量Hash冲突时也能使用红黑树让查找的时间复杂度由O(n)降低为O(logn)。至于红黑树里面添加数据的源码我就不手撕了，确实比较复杂，我撕不动…知道红黑树是一颗特殊的二叉平衡查找树即可。<br></p>
<h2 id="resize-方法解析"><a href="#resize-方法解析" class="headerlink" title="resize()方法解析"></a>resize()方法解析</h2><p>在前面的介绍里我们可以注意到，在插入新数据以及首次插入数据时，HashMap都进行了一次判断是否需要扩容。我们知道Java中数组的长度是固定的，当我们需要扩容时，肯定需要用一个新的数组来替换老的数组，并将数据迁移过去。而这些操作在HashMap中全部体现在resize()方法中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//----------------------以下为第一部分，负责初始化定义新容器大小与threshold-----------------------------------</span></span><br><span class="line">    <span class="comment">//获取旧的table，旧的threshhold，旧的长度</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//如果容器容量已经到达最大值，则不再扩容了，threshhold也设置为最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义了新容器大小为旧容器大小的两倍，新threshold也为旧threshhold两倍</span></span><br><span class="line">        <span class="comment">//注意这里采用了 &lt;&lt; 1操作即地位补0的方式，与 *2 的效果一样且速度更快</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果hashtable尚未定义，则初始化定义容量以及threshold</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">       <span class="comment">//生成新的newTab来替换之前的oldTable</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">   <span class="comment">//-------------------------------------------------------------------------------------------------------</span></span><br><span class="line">   <span class="comment">//-----------------------------以下为第二部分，负责将oldTab的数据导入到newTab中------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历oldTab</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">//如果oldTab[j]只有一个Node，那么直接重新计算index，将Node放入</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="comment">//如果oldTab[j]已经转换为一个红黑树，则对红黑树进行rehash</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//对于链表进行操作</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//计算链表oldTab[j]新的索引值，如果索引不需要更改，则由loHead链表保存它们</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//计算链表oldTab[j]新的索引值，如果索引需要更改，则由hiHead链表保存它们</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//循环结束。如果不需要改变索引位置的Node则直接将loHead保存在newTab[j]中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果需要改变索引位置的Node则直接将hiHead保存在newTab[j]中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容代码是非常精巧的，虽然看起来比较复杂，但是如果去细究的话就会发现里面用了很聪明的优化方式。我们可以将代码分为两部分去看(已用注解区分)</p>
<p><strong>第一部分：初始化新容器</strong></p>
<p>前面我们说了，扩容肯定是需要用一个新的哈希桶来替换旧的哈希桶的。那么HashMap里面由于为了优化取模速度(上文已提及)，让哈希桶的长度必须为2的n次方，所以每一次扩容只需要将原有哈希桶的大小扩充一倍即可。于是我们就可以看到newCap = oldCap &lt;&lt; 1，这种通过位偏移的方式相对于使用newCap = oldCap * 2的方式效率会更高，也算设计团队的一个优化地方。同时我们在代码里也能看到，如果哈希桶的容器仍未定义即第一次使用时，也会进行数据初始化，这一部分很简单就不再叙述了。</p>
<p><strong>第二部分：将旧哈希桶的数据导入到新哈希桶中</strong></p>
<p>这一部分讲道理思路其实也很简单。在JDK1.7中的实现方式是遍历旧哈希桶中的所有Node(rehash)，重新计算它们的索引位置，依次放入到新的哈希桶中。(值得注意的是JDK1.7中旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，感兴趣的去看JDK1.7的源码就能明白其中意思了)而在JDK1.8中，HashMap采用了一种更聪明的方式。由于哈希桶的长度一定是2的n次方，所以对Node的重新计算索引也就是hash值对length-1重新取模的索引值，要么是原索引的值，要么是原索引+原length的值。可能比较绕，看下图就明白了，n为table的长度，图(a)表示扩容前的key1和key2两种key确定索引位置的示例，图(b)表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/HashMap_4.jpg" class="lozad"></p>
<p>我们会发现确定索引值是否要变化的关键，其实在于hash值新增的那一位bit，如果那一位为0，则新的索引位置就是原索引位置，如果那一位为1，则新的索引位置就是原索引位置+oldLength。所以我们重新计算索引时根本不需要重新计算它们的位置，只需要判断新增的那一位bit是0还是1就可以了，大大优化了效率。因此我们再源码中可以看到对 (e.hash &amp; oldCap) == 0 进行了判断，如果为true代表索引为原位置，如果为false代表索引为原位置+oldLength。同时我们也可以发现在代码段中定义了loHead与hiHead两个链表，一个是存放不用变更索引位置的Node，一个是存放变更索引位置的Node。定义这两个链表使得变更新索引位置的链表不会像JDK1.7一样倒置。</p>
<h2 id="get-，remove-等方法的思路"><a href="#get-，remove-等方法的思路" class="headerlink" title="get()，remove()等方法的思路"></a>get()，remove()等方法的思路</h2><p>至此我们已经基本了解完了HashMap的put方法的流程。当然HashMap也提供了get()，remove()等方法，但是大致思路与put是基本一致的。都是要通过计算key的hash值确定，哈希桶的位置，然后判断是否有哈希冲突的情况，如果有的话再判断是链表还是红黑树，最终确定到对应的值。具体的流程都是一样的，再次就不赘述了，可以自己跟着源码看下去。</p>
<h1 id="HashMap的线程安全问题"><a href="#HashMap的线程安全问题" class="headerlink" title="HashMap的线程安全问题"></a>HashMap的线程安全问题</h1><p>开始的时候我们就已经提到HashMap是线程不安全的，那么为什么说HashMap是线程不安全的呢？ 在JDK1.7中，resize时更新到新的索引位置时采用的是头插法的方法，会让链表导致。但是在多线程的情况下头插法会出现链表回环的情况(解释比较复杂，就不详细说明了)。在JDK1.8中，我们已经取消了这种方式，但仍然会出现线程不安全的情况。如putVal中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已省略大量代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     ...</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">//确定哈希桶的索引位置，如果里面目前没有数据，则直接插入新Node进去</span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">     tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     ...</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在putVal中如果线程A与线程B同时进入了该方法，同时判断了(p = tab[i = (n - 1) &amp; hash]) == null 为true，这样会导致其中一个插入的数据会被丢失的情况出现。</p>
<p>其实HashMap使用了公用的变量Node[]table进行各类复杂的操作，是肯定会出现线程不安全的情况的，所以使用的时候一定要注意。当然也不是没有解决方案，最早方法自然就是使用HashTable，但是众所周知HashTable的效率很低，它对每个操作都加了锁。这里推荐使用java.util.concurrent包下的ConcurrentHashMap，它使用了分段锁的方式细化锁的粒度，在保证了线程安全的同时也不比HashMap慢多少(ConcurrentHashMap也是面试常问的点，后续有时间也一定会专门写一篇对其原理的分析)。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>那在最后来总结下我个人认为的HashMap的精髓</p>
<ol>
<li>HashMap的是一个链表+数组+红黑树的存储结构</li>
<li>确定哈希桶位置使用了 hash &amp; length-1 的方式显著提高了效率</li>
<li>JDK1.8中，链表长度超过8将会自动转换为红黑树，提高了查找效率</li>
<li>HashMap是线程不安全的，想要线程安全请使用ConcurrentHashMap</li>
</ol>
<br>
<br>

<p><strong>小结后的小小结：</strong></p>
<p>终于完成了我的第一篇正式博文。突然发现写博客真的是一个很累的事情啊！！！为了这篇博文，看源码看资料写博文这一系列操作花费了我大概有10个小时，不过对我自己也有了一个很大的提升，不管怎么说算是一个好的开始？哈哈哈，希望能坚持下去吧。over！</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">美团技术博客——Java 8系列之重新认识HashMap</a> [图片素材来源]</p>
<p><a href="https://www.cnblogs.com/qingyunzong/p/9143249.html" target="_blank" rel="noopener">漫画：高并发下的HashMap</a></p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>那就写在开始吧</title>
    <url>/2019/10/13/%E9%82%A3%E5%B0%B1%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B%E5%90%A7/</url>
    <content><![CDATA[<h1 id="来自灵魂的四个追问"><a href="#来自灵魂的四个追问" class="headerlink" title="来自灵魂的四个追问"></a>来自灵魂的四个追问</h1><h2 id="问：你是谁呀？"><a href="#问：你是谁呀？" class="headerlink" title="问：你是谁呀？"></a>问：你是谁呀？</h2><p>答：我是一名毕业于双非末流大学，没啥毅力，没啥能力,有点强迫症,喜欢折腾一些奇奇怪怪的东西的程序猿？</p>
<h2 id="问：你这个博客想记录什么？"><a href="#问：你这个博客想记录什么？" class="headerlink" title="问：你这个博客想记录什么？"></a>问：你这个博客想记录什么？</h2><p>答：em….其实我还没想好，应该主要就是一些技术有关的帖子吧，把平日里解决问题的方法，以及一些总结的一些技术贴记录下来。当然也可能神经兮兮的写几篇矫情的文章？反正我这个博客估计到死也没人会来看，我想写的主要都是给自己看的，估计多年后的我看到年轻时的自己写的这堆不专业的东西会笑出声吧哈哈哈。</p>
<a id="more"></a>
<h2 id="问：你为什么想要开始写博客？"><a href="#问：你为什么想要开始写博客？" class="headerlink" title="问：你为什么想要开始写博客？"></a>问：你为什么想要开始写博客？</h2><p>答：前段时间为了应付面试，做出了不少的努力。虽然没有进大厂，但好歹进了一个不算太差的互联网公司？这期间对整套Java程序员应该有的技术栈有了一定的了解，也发现学到的新东西，如果不把它表述出来，其实根本不是自己的，复盘学习非常重要！因此打算把前段时间写的笔记再整理下，记录到博客上。未来的话，如果有新学的东西或者遇到的问题，我也会记录下来。当然，听说写博客，对简历还蛮加分的哈哈。所以未来的Hr，如果你看到这个人写的这段话，就把他招进来吧，毕竟他还蛮努力的= =</p>
<h2 id="问：你会坚持下来吗？"><a href="#问：你会坚持下来吗？" class="headerlink" title="问：你会坚持下来吗？"></a>问：你会坚持下来吗？</h2><p>答：其实我觉得能坚持写博客的人都很厉害。这是一个很考验人的事情，我当然希望我是一个很厉害的人，虽然我的这个博客可能更新的不会太勤，但是会尽力坚持下来。先定个小目标，一周一篇？算了，还是一个月一篇吧。。。</p>
<hr>
<br><br><br><br><br><br><br>
<font face="黑体" color="red" size="1">
我知道我是一个平凡的人，但我也知道我想要什么并会为之努力。<br>
希望多年后的我能配得上自己的野心，也不会辜负自己所受的苦难吧。<br>
(矫情的话都偷偷写在最后)
</font>
]]></content>
      <categories>
        <category>乱七八糟</category>
      </categories>
  </entry>
</search>
