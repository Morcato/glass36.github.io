<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>疫情项目+云诊室接入益丰药房项目总结</title>
      <link href="/2020/02/15/%E7%96%AB%E6%83%85%E9%A1%B9%E7%9B%AE+%E4%BA%91%E8%AF%8A%E5%AE%A4%E6%8E%A5%E5%85%A5%E7%9B%8A%E4%B8%B0%E8%8D%AF%E6%88%BF%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/15/%E7%96%AB%E6%83%85%E9%A1%B9%E7%9B%AE+%E4%BA%91%E8%AF%8A%E5%AE%A4%E6%8E%A5%E5%85%A5%E7%9B%8A%E4%B8%B0%E8%8D%AF%E6%88%BF%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在是2020年2月14日23点23分，是的没错，在这么一个具有纪念意义的情人节里。优秀的我竟然在写项目总结？!要不要这么惨，希望明年别这样了（美好的愿景还是要有的）。好了，废话不说，这大半个月，因为疫情的影响，作为互联网医疗的一名尽职的搬砖工，经历了惨无人道的摧残。这段时间，让我快速适应了敏捷开发的节奏，感觉每天的活动就是吃饭，撸代码，开会，睡觉。怎么说呢,最近确实有点怀疑人生，我觉得这似乎并不是我想要的生活，但是也不得不承认，这期间我的能力得到了一个很大的提升，现在有复杂的需求到我这里时，我都不会像以前那么懵逼了。</p><p>这段时间一共开发了两个项目：1.疫情项目,2.云诊室接入益丰药房项目。鉴于时间很紧，我就把它们合在一起写了。</p><h1 id="问题与反思"><a href="#问题与反思" class="headerlink" title="问题与反思"></a>问题与反思</h1><h2 id="1-腾讯健康渠道用户无法流转医助导致会话超时被关闭"><a href="#1-腾讯健康渠道用户无法流转医助导致会话超时被关闭" class="headerlink" title="1.腾讯健康渠道用户无法流转医助导致会话超时被关闭"></a>1.腾讯健康渠道用户无法流转医助导致会话超时被关闭</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>腾讯健康渠道过来的用户，从2月7号 13:12:35 开始无法流转医助导致会话超时被关闭，截止到 2月8号12:26:25影响了2089个会话。并且发消息会回复，正在排队中，前面0人。</p><p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/YQ_conclude_1.jpg" class="lozad"></p><h3 id="核心代码原因"><a href="#核心代码原因" class="headerlink" title="核心代码原因"></a>核心代码原因</h3><p>同事的代码出现bug。创建会话时使用的是我们之前重构的代码，而发送消息却走了老代码，导致不匹配，出现了问题。</p><h2 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h2><p>2020-2-7 23:38 发现有渠道会话报 “当前排队0人”，以为是正常的消息失败，没有立即处理</p><p>2020-2-8 09:20 老大发现腾讯健康咨询量下降得厉害，找到timmy调查。</p><p>2020-2-8 10:52 被拉群一起定位问题。</p><p>2020-2-8 11:32 发布代码解决。</p><h3 id="故障复盘"><a href="#故障复盘" class="headerlink" title="故障复盘"></a>故障复盘</h3><p>我在2月7日 23：38分收到医助群的反馈，开始检查问题，发现i企鹅家庭医生的会话，部分消息走重构后的核心代码，部分消息却走以前的代码。判断由于websocket不稳定，前端使用消息补偿机制导致没有分配过的会话进行发消息，最终在自动回复处理时返回系统消息当前排队0人。当时使用了小程序再次测试了一下，发现消息可以成功分配，认为就是websocket不稳定导致该问题，触发条件较苛刻改动量较大，于是仅将该问题在tapd上列了优化。</p><p><strong>当时判断的依据</strong>：调用旧代码方法的路径只有两处，一处为消息补偿，一处为websocket发送消息。</p><p>由于看到session的来源是i企鹅家庭医生隶属于自有渠道，在webscoket发消息时一定会被过滤，因此只可能是因为websocket不稳定导致前端发送消息补偿导致的问题。</p><p>同时自己使用i企鹅家庭医生小程序发送消息可以成功，更确定是因为当时websocket不稳定导致的。</p><p><strong>判断失败的原因</strong></p><ol><li>不知晓最近接入了疫情-腾讯健康等渠道，原先处理websocket消息的代码有修改–&gt; 导致部分消息走旧代码的直接原因</li><li>消息补偿模块的代码没有日志查看，就没有仔细确认该问题来源是否真的是消息补偿导致的（实际上可以直接查询调用接口的次数）–&gt; 导致误决断问题源的直接原因</li><li>原先欢迎消息的逻辑有问题，会将所有自有渠道的信息转换成i企鹅家庭医生。–&gt; 导致自测时使用i企鹅家庭医生小程序发送消息，发现没有异常，判断不是必现问题</li></ol><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>这是我来到公司后，遇到的最大的BUG,影响了上千个腾讯健康用户还写了RCA。虽然核心问题不是我的，但是我因为我在排查问题时没有精准定位到问题，没有及时解决，最终造成了很大的影响，也有着不可推卸的责任。归结了下判断失败的原因我觉得该改进的点有：</p><ol><li><p>一个好的小组应该内部沟通要清晰完善，知道各自都在做什么工作。这次的问题很大原因是我不知道最近其他人有接入新渠道。</p></li><li><p>对于线上问题没有直接判断证据时，不能轻易下结论，必须要<strong>慎重</strong>！！</p></li><li><p>项目里应该加上足够多的日志，方便排查。</p></li><li><p>最后这一条呢是对我自己说的，我希望我自己不要去怕背锅，遇到这种影响极大的BUG不要去慌张，该是自己的也是逃不掉的。重要是能在之后吸取教训，不要再犯了。虽然说起来容易，但是我也知道做起来很难，努力吧！</p><h2 id="2-合理估算开发时间，不要轻易去承诺完成节点"><a href="#2-合理估算开发时间，不要轻易去承诺完成节点" class="headerlink" title="2.合理估算开发时间，不要轻易去承诺完成节点"></a>2.合理估算开发时间，不要轻易去承诺完成节点</h2><h3 id="事件回顾"><a href="#事件回顾" class="headerlink" title="事件回顾"></a>事件回顾</h3><ol><li><p>疫情项目P1：前端询问接口完成时间，拍脑袋就说明天一定给。结果发现并没有那么简单，出现了很多其他问题，第二天又拖到中午给，最后到晚上6点钟才把接口交付了。但是过年期间人家也很忙，第二天又要提测，害的前端小姐姐凌晨四点还得帮我调代码= =，心里很是过意不去。</p></li><li><p>疫情项目P3: 站会时询问一个功能何时做完，虽然知道自己手上活很多，但是还是强行说今天。最后时间又一拖再拖。</p></li><li><p>接入益丰药房项目：由于项目自己负责，自己心里估算了时间和实际的时间根本不一样，导致坑自己，熬了两天晚上才完成。</p></li></ol><h3 id="原因和总结"><a href="#原因和总结" class="headerlink" title="原因和总结"></a>原因和总结</h3><p>我感觉自己太年轻了，算不出精准的开发时间。每次都把事情像想很简单，但是计划总赶不上变化，这个我目前没有什么好的办法，只能积累经验吧，目前策略是在自己原先预估时间上再多加百分之五十的时间。然后是在站会的时候不要慌，时间紧张做不完就是做不完，只要有理有据即可，没必要逼自己，这也会让项目经理对时间判断错误</p><h1 id="做的好的点"><a href="#做的好的点" class="headerlink" title="做的好的点"></a>做的好的点</h1><h2 id="1-云诊室接入益丰药房项目"><a href="#1-云诊室接入益丰药房项目" class="headerlink" title="1.云诊室接入益丰药房项目"></a>1.云诊室接入益丰药房项目</h2></li></ol><p>哈哈哈，还是要夸一下自己。云诊室接入益丰项目是交由我全权负责的。从TD,到定义代码结构，到开发都是自己来做的。刚才呢把项目发上线了，虽然做这个项目很辛苦，但是确实还是挺有成就感的。说说自己觉得自己做的好的点吧：</p><ol><li><p>码代码前提前做好规划，画好流程图，做好架构设计。</p><p>虽然这些都是公司要求，但是全由自己来做时是一个不小的挑战。流程图画的挺难看的，以后可以多学学UML类图，时序图之类的。不过在画好流程图，做好TD的情况下，再写代码时的感觉真的不一样诶，整个流程再脑海里有一个清晰的规划，不会再想以前一样，一脸懵的直接进行开发。</p></li><li><p>遵守开闭原则，使用SPI的方式</p><p>之前不懂SPI，第一次接触也是在之前做咨询中台迁移项目时看到的。不过确实很好用，很好的实现了对”扩展开放，对修改关闭”。考虑到未来可能有会接入多个药房，而每扩展一个药房就实现一个SPI，再根据订单号使用工厂模式指定SPI。</p></li><li><p>使用Builder对消息通知优化</p><p>当医生下单或者患者支付成功时都需要给医生和患者推送不同消息，而患者又根据渠道分成小程序和微信渠道。所以一开始写的时候写的特别乱，自己也很难看懂。后来实在看不下去了，开始对代码进行优化，首先是将消息通知抽成两个维度，推送方向(医生/患者)以及推送渠道。然后针对各种渠道build各自的消息，再判断推送方向，把整个消息结构就构建出来了。这比一个一个消息构建效率高了很多，而且更易理解，虽然弄到半夜三点，但是还是很开心（可能这就是我为什么能坚持不转行的原因？哈哈哈）</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不知不觉又快到凌晨3点了。写完这些篇总结的期间，顺便还把云诊室接入药房的项目发布了，希望后面能多留些时间给些自己去学习吧。这几天实在是太忙了，我感觉已经有点不像自己了。本来呢，有好多话想在结尾抱怨一下，但是仔细想想现在所经历的一切其实是自己有所预料到的，这些记忆就留在心中吧哈哈。</p><p>最后的最后，愿疫情早日结束，武汉加油！！❤</p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>咨询服务迁入中台项目总结</title>
      <link href="/2020/01/18/%E5%92%A8%E8%AF%A2%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%85%A5%E4%B8%AD%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/18/%E5%92%A8%E8%AF%A2%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%85%A5%E4%B8%AD%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周发布了我来到新公司写的第一个项目，出现了很多我没有想到的问题也导致了后续的疯狂加班。我觉得有必要记录一下，以后每完成一个项目都应该有所总结。</p><h1 id="问题与反思"><a href="#问题与反思" class="headerlink" title="问题与反思"></a>问题与反思</h1><h2 id="1-患者排队问题"><a href="#1-患者排队问题" class="headerlink" title="1.患者排队问题"></a>1.患者排队问题</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>项目发布当晚所有进入排队状态的患者，至第二日早上空闲了也没有分配医助进行处理。在问题解决前有约50名患者受到了影响，其中大部分还是腾讯渠道的付费患者。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>发布前两日，额外增加了新的两个渠道，然而我并不知情。最后导致代码的枚举转换对应不上，直接扔出异常，影响了所有排队的用户。</p><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>这个问题其实是一个非常严重的线上问题，幸好现场的医助没有向上反馈，否则真的就翻车了。<br>之前修改这一块的时候，想着在会话排队这一块所有渠道都是一样的不需要做特殊处理，就让所有渠道都走重构的代码了。但万万没有考虑到，如果后续新加了渠道，会扔出异常的问题。其实这也是自己设计的问题，代码应该是要遵循”开闭原则”，不能让新增的东西去影响我整个核心业务的走势。</p><h2 id="2-项目发布前一小时才发现线上有部分数据有问题"><a href="#2-项目发布前一小时才发现线上有部分数据有问题" class="headerlink" title="2.项目发布前一小时才发现线上有部分数据有问题"></a>2.项目发布前一小时才发现线上有部分数据有问题</h2><h3 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h3><p>线上有部分医助没有手机号，导致新写的脚本将无法为他们刷新doctorId，会影响到重构的代码所有的逻辑。最后手忙脚乱，临时改代码生成虚拟手机号。</p><h3 id="反思-1"><a href="#反思-1" class="headerlink" title="反思"></a>反思</h3><p>其实这个问题在很早之前我就知道有了，但是因为同事说没手机号的人之后再记录，反馈给产品。就没有当回事了，但其实这个是会影响到主流程的，当时没有太当回事，临了上线才注意到这个问题的严重性，已经来不及找产品了。以后的话，不要把东西都太想当然了，很多细节是必须要注意的。</p><h2 id="3-部分患者发送的消息绕开医助直接到医生"><a href="#3-部分患者发送的消息绕开医助直接到医生" class="headerlink" title="3.部分患者发送的消息绕开医助直接到医生"></a>3.部分患者发送的消息绕开医助直接到医生</h2><h3 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h3><p>发布第二日，有同事发现部分腾讯患者没有通过医助就直接被系统分配给了医生，这是不符合我们的分配原则的。</p><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p>代码逻辑中会有分配给上一次沟通过的医助。而我对这块业务其实并不知情，重构都是看以前的代码进行调整的，最终导致sql语句有漏洞。</p><h3 id="反思-2"><a href="#反思-2" class="headerlink" title="反思"></a>反思</h3><p>这个问题真的是我自己导致的，不过因为触发条件比较苛刻，所以对于线上的影响并不大。但是这个问题理应在上线前就被发现。究其根本原因还是我写的单元测试没有覆盖好，因为当时处理消息要考虑的分支实在是太多了，我个人觉得这一块是比较简单的不会出什么问题。然而正是这些没覆盖到的单元测试出现了问题。</p><h2 id="4-重构完成后新增自有渠道需要改的代码很多"><a href="#4-重构完成后新增自有渠道需要改的代码很多" class="headerlink" title="4.重构完成后新增自有渠道需要改的代码很多"></a>4.重构完成后新增自有渠道需要改的代码很多</h2><h3 id="现象-3"><a href="#现象-3" class="headerlink" title="现象"></a>现象</h3><p>现在在做视频服务咨询，又新接入了一个魔镜的自有渠道。发现因为中台那里没有接入这个渠道，所以得通知他们加渠道，其次自身所有转换类都要把这个渠道加上</p><h3 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h3><p>这个问题很明显就是代码违反了”开闭原则”，其实整个咨询服务重构就是为了解决这个问题，于是采用了SPI的方法。因为我自己当时接手这个项目也是刚刚进入公司，对业务什么的都不是很了解，听了TD，似懂非懂的就开始写代码了，但没有考虑过他们为什么要这么设计，最终导致有部分代码有点坏味道。</p><h3 id="反思-3"><a href="#反思-3" class="headerlink" title="反思"></a>反思</h3><p>写代码前应该要充分的考量和设计，而不是写到哪设计到哪。我觉得这就是所谓码农和软件开发工程师最大的区别了。后续有时间，我应该自己把代码再优化一下，使得后续新增渠道，对核心代码没有任何影响才算合格。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="针对单元测试"><a href="#针对单元测试" class="headerlink" title="针对单元测试"></a>针对单元测试</h2><p>写单元测试时可以用一个场景图把业务点都列出来。比如会话分配的业务点1，业务点2，各个业务点再细分最终要落到要设置哪些字段对应的业务效果是什么。比如值班消息需要返回reply字段，会影响提示音发送，那么我的单元测试就应该在最后检查这个字段的值。</p><p>明明写了很多单元测试最后还是发现少考虑了，就是因为自己都没理清楚有哪些业务点，其次也是自己懒了，不想去mock那么多数据。</p><h2 id="针对代码设计"><a href="#针对代码设计" class="headerlink" title="针对代码设计"></a>针对代码设计</h2><p>以后一定要<strong>先做代码设计，再写代码</strong>，要做到”以终为始”。</p><p>具体做法的话，完全可以在写代码前，把整个代码的骨架搭好，里面可以先用空实现以及TODO，等架构搭好了以后，自己评估或者找人帮忙评估。最后再一步步去实现里面的代码。</p><h2 id="针对自己"><a href="#针对自己" class="headerlink" title="针对自己"></a>针对自己</h2><p>这个项目是我来公司的第一个项目，用时一个多月，时间其实是非常宽裕的，也不是很忙。但是最后上线还是出现了这么多问题，只能说我自己有很大的问题。</p><p>首先是自己对公司业务还不是很熟悉，毕竟刚来，他们讲的很多东西我都听得很懵。这个没有人能帮自己，必须要自己去主动了解，多使用下自己的产品。</p><p>接着是自己的沟通，项目讨论的时候，可能也是因为自己的不自信吧，想问的每句话都会在心里想好再说出来，怕说的东西太幼稚，被其他人鄙视= = 但是正是因为自己的顾虑太多，说的就更少了，许多有疑问和质疑的地方就应该提出来。</p><p>最后是承担，很奇怪，当线上出现BUG的时候我的第一反应是去想这个会不会和我有关，和我有关的话该怎么甩锅。是自己的问题就是自己的问题，没什么好推脱的，而且同组的其他人真的都很认真负责，对线上的BUG都是第一时间去查的。还有很多恶心的现象，我自己嫌麻烦，看到有人在跟进了，自己就不管了，其实是知道那些现象可能是和自己有关的。承担的品格无论在工作中还是生活中我都应该不能去忘记。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一周过得很不开心，也很累。经历了发布项目的通宵，疯狂加班，后续处理线上问题与紧急的新需求搞得自己心力交瘁。说实话，互联网公司的压力似乎比我想象的要大，尤其是当我看到因为自己代码报错导致耽搁的患者聊天记录里质问我们回复效率咋那么低的时候，我当时真的快疯了，这和之前在传统行业开发的感觉是不一样的，QA只是负责大致验收下产品主流程能不能通，具体的产品质量应该是研发去负责的。我甚至开始怀疑自己是不是不应该进入互联网行业的圈子，但是我总得试一试不是么。希望这段时间过后，一切都能变好吧。Best Wish！</p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020你好呀</title>
      <link href="/2020/01/01/2020%E4%BD%A0%E5%A5%BD%E5%91%80/"/>
      <url>/2020/01/01/2020%E4%BD%A0%E5%A5%BD%E5%91%80/</url>
      
        <content type="html"><![CDATA[<h1 id="2020年的第一篇博客"><a href="#2020年的第一篇博客" class="headerlink" title="2020年的第一篇博客"></a>2020年的第一篇博客</h1><p>em…由于 <del><em>我的懒惰</em></del> 最近很忙，这段时间都没有更新我的博客。不过毕竟是20世纪20年代的第一天，我觉得仪式感很重的我总得做些啥吧。本来呢是想在微博上总结下2019年的，不过写了一点就不太好意思发了，可能我不太适合表达这些矫情的东西。想了想还是写在这里吧，反正这个博客也没几个人知道，更不会有人来看的（可能？）。</p><h2 id="2019流水账"><a href="#2019流水账" class="headerlink" title="2019流水账"></a>2019流水账</h2><p>仔细想想2019年我的心路历程还是挺跌宕起伏的，这是我毕业的第一年，我能感觉到周围的人还是把我当小孩子看，虽然讨厌这种感觉，不过我身上的稚气也确实没法压制住- -</p><h3 id="1月"><a href="#1月" class="headerlink" title="1月"></a>1月</h3><p>1月份太远了，竟然有些没印象了诶。不过我还记得19年的跨年夜晚上，我一直等着想看看谁会主动给我发条元旦快乐，最后啥也没有很尴尬（今年似乎也没好到哪去哈哈哈）。</p><p>对了，突然想起来还有一件事情，因为我的代码出了问题把公司测试环境后台所有数据全部删得一干二净。哈哈哈，当时脑子里第一个想法竟然是删库跑路？</p><h3 id="2月"><a href="#2月" class="headerlink" title="2月"></a>2月</h3><p>2月份过年了奥，过年前后我似乎都没有怎么请假，还和甘肃，重庆的同事疯狂调接口，这似乎也是一个令人难过的故事。现在的年好像都没什么年味了，只记得索然无趣的呆在家里一个礼拜，可能是自己长大了吧，不再对很多事物充满好奇，这或许也是一种悲哀。</p><h3 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h3><p>3月份去了一次杭州和2个舍友聚了一下。当时3个人在西湖上划着船，吹着风，哼着歌，我至今还记得那种感觉，毕业之后我似乎好久没那么放松开心了，当时想着一辈子就这样舒舒服服的也不错，不过生活还得往前走，该面对的还得面对。</p><h3 id="4月"><a href="#4月" class="headerlink" title="4月"></a>4月</h3><p>4月份开始了公司某个项目的代码重构编写设计。这个重构时间跨度很大，我原先对这个项目本身重构是报着很大热情，也全心全意的投入的，因为种种原因整个重构质量极差，让我挺难过的，我现在也常常在反思是否有更好的解决方法去应对当时的困难，不过4月份开始时还是蛮开心的啦。</p><p>同时4月份是我下定决心开始好好准备跳槽的时间，其实刚来公司的时候就已经有些计划开始慢慢看些技术相关的书和教程了，但是没有针对性的学习。记得当时花了99元买了一个盗版网课视频，从Mysql性能优化到Java虚拟机，每天下班无论多晚都会看上一两个小时，再做做笔记啥的。现在想想还蛮佩服当时自己的那个毅力的。</p><h3 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h3><p>5月除了照常每天学习外，似乎没什么让我印象深刻的事情了，好像吃了好多全家的冰激凌。当时还想着每吃一种冰激凌拍张照片，最后录一个vlog，只是后来觉得很无聊就放弃了。</p><h3 id="6月"><a href="#6月" class="headerlink" title="6月"></a>6月</h3><p>em…6月份初我记得一直嘴贱说自己想要出差，羡慕那些去重庆出差，哈尔滨出差的同事，很舒服。结果6月底就被安排去了云南…然后这一去就是40天…好像这件事情以后我这个无神论者竟然有点动摇了，难道冥冥之中自有天意？</p><h3 id="7月"><a href="#7月" class="headerlink" title="7月"></a>7月</h3><p>整个7月份基本上都是在云南度过的，讲讲这段时间的经历吧。刚去的时候其实很开心，现场客户那里基本上5点半就下班了也不要加班啥的，下班以后坐在宾馆的沙发里，喝着维他柠檬茶，听着焦迈奇的《我的名字》，再看着窗外的蓝天白云是真的舒服。周末的时候再一个人去滇池吹吹风或者去品尝一下玉溪各类小吃(怒推包浆豆腐，鳝丝米线！)，一切是那么美好。</p><p>不过呢，时间一长那种无聊，想找人沟通的感觉就开始强烈了起来，和我同行的两个同事，虽然知道人都还不错，但是实在是聊不到一起。一个年龄比我大2岁的研发，但是感觉思想比我老了20岁，每次见面真的是尬聊。还有一个年龄真的比我大20岁的售前，给人的感觉是那种“老奸巨猾”哈哈哈。他们相比我的确世故了很多，两人住一间房，发票开两间房的顶额，不像我老老实实实报实销- -可能是我幼稚吧，但是如果“成熟”是要变成这样，那我宁愿永远保持现在幼稚的样子。</p><h3 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h3><p>8月份已经回到上海了，8月初的时候就又去了一次杭州找舍友。这一次是我们4个时隔1年多再一次的聚齐，其实还蛮珍惜的。可惜的是黄大哥要去帮姐姐搬家，大家也就一起吃了顿饭稍微聊了聊以前的事情就分别了，没留张合影还挺遗憾的，不知道下一次4个聚齐是什么时候了，也不知道还能聚齐几次了吧。</p><p>哦对，8月份还有我的生日，我当时许下了找一份好工作的心愿…现在来看应该也算实现了？8月份的时候是我学习计划的末期，当时每天整理笔记，看面试题到2,3点，说实话真的挺累的，但是也是我提升最大的一个时期。</p><h3 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h3><p>9月份，可以算我2019年最难的一年了吧。当我把常考的题目复习的差不多了，我就开始投起了简历。起先我挺有自信的，在拉钩上精心挑选符合自己的岗位，我不是那种没有自知之明的人，我选的岗位都是我认为我能胜任的，也并没有去妄想挑战互联网第一梯队的企业。但是一天，两天，三天…一周后，我所有“精心”选择的岗位，没有一个有意向联系我。我至今不知道为什么，可能是因为我的简历，我的专业亦或是我的学历,但是我知道的是我当时真的慌了。我开始慌不择路，无论大公司小公司，什么样的要求都去投递一次，甚至还在网上各种尝试找人内推。这样做确实零星有公司联系我了，但是绝大多数都是外包公司以及就几人的小创业公司。那段时间我心中唯一的支撑塌了，我不明白为什么我付出了半年的努力，现今连一个面试的机会都拿不到。其实我是一个还蛮自负的人，但是那一刻我感到我的自负和自尊被这个社会按在地上反复摩擦。那段时间我下班了以后，常常一个人呆着怀疑人生，看看隔壁那栋LOGO明显的腾讯大楼自嘲，却又笑不出声。</p><p>不过值得庆幸的是，我也没有走到绝路。我收到了我现在这家公司的面试邀请，不得不说努力还是有用的。面试问的问题虽然不难，但是如果没有系统的去复习也绝对答不出来，我的表现似乎还算不错，HR也成天打电话问我的意向。这家公司确实不错，互联网医疗独角兽，薪资也开的还可以，但是说实话是低于我一开始的预期的。不过对于当时的我而言已经是黑暗中的一点光明了，我还是犹豫了很久，最后感觉他们的学习氛围很好可以提升很多以及舍友的劝说下，我坚定了自己的选择。现在呢我也没有后悔这个选择，反而很庆幸来到了这里。</p><p>这一章写的有点多，因为9月份确确实实对我的影响很大。经过这段时间，我突然感觉我自己成长了不少。如果说要总结这个月学到的话，那就是一句：<em>减少幻想却又保留希望，珍惜眼下却又憧憬未来。</em></p><h3 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h3><p>10月初趁着十一去了趟北京和大学的好友们见见面。对我而言也是一个放松的时间，让我从9月份的紧绷着舒缓了下来。这期间真的吃了好多北京的特色，贼好吃的北京烤鸭，冰糖葫芦，炸酱面，铜锅涮肉以及喝了一口恶心一整晚的豆汁儿！（如果有人问我有没有吃过屎，我一定会说没有，但是我想我知道那个味道- -)一年多未见，大家似乎都没怎么变化，不过夜幕降临，一起喝酒时，才知道大家过的都不容易，后面喝的有点晕了只记得大家一起说了很多很多。咳咳，sbt太恶心了，吐的时候不仅吐到我身上，头都栽进马桶里了。这一次分别的时候，大家都没有哭，确实不能再像去年那样了。</p><p>北京回来后提出了离职，我导师说他知道我一定会提出离职的。说实话我挺敬佩他的，工作上对人对事都很认真，私下里却是一个很温柔的人。这家公司虽然有诸多令我不太喜欢的地方，但是这里的很多人都给我留下来很深刻的印象。或许多年之后，想起刚毕业就遇到了他们也会会心的笑吧。</p><h3 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h3><p>11月初去了麦田音乐节很开心，了解了一个宝藏棱镜乐队和一个宝藏小姐姐哈哈。棱镜的歌真的怒推，每首歌都超级好听！em..还有一个宝藏小姐姐，熟了之后发现她和外表看上去其实是很不一样的，她是一个内心很敏感细腻的人，会把所有问题都归咎在自己身上，但是她不知道她自己真的超级优秀，超级棒，希望她能走出这个困局吧。（突然想起来，这个小姐姐有一定概率会翻到我的博客，嗯，没错说的就是你，超级棒！）</p><p>之后的话就从原公司离职，无缝衔接来到了现在的这家公司。来到了这里我似乎打开了一个新世界的大门。我终于知道原先的研发流程是多么落后，这里的自动化集成测试，多环境部署，Apollo配置，中台战略，TDD,DDD等等等至今我都没有全部理解。最让我感动的是这里的研发氛围，可能是因为CTO是阿里出来的大手子，我觉得这是一家尊重程序员的企业，，更加注重培养程序员而不是一味的压榨。周围的人都很厉害，代码思路非常明确，不过我相信有一天我也可以做到！</p><h3 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h3><p>2019年的最后一个月似乎就是不停的在学习吧。目前在重构一个项目，很多东西我都不熟悉，压力说实话有点大。我感觉每次代码review的时候我都不是很有自信，思路也不是很清晰，我好怕自己会被大家瞧不起。em…故事还在继续，我也还在继续，未来谁知道呢？</p><h2 id="2020年？"><a href="#2020年？" class="headerlink" title="2020年？"></a>2020年？</h2><p>发现上面自己扯了好多流水账…打完这些字，回想下2019还挺精彩的。</p><p>今年跨年夜我也许下了一个心愿，但是..嘘..不能说，说出来的心愿就不能灵验了呢。</p><p>2020年和往常每年一样，我都有一个新年计划，不过我现在还在制定完善，这一次我得做一个可以量化的新年计划，等明年再来看看实现没，先在这里留个位置吧</p><h3 id="2020新年计划"><a href="#2020新年计划" class="headerlink" title="2020新年计划"></a>2020新年计划</h3><p>最后想了想，我决定把2020年的新年计划表移到首页去，方便督促下自己！：<a href="/plan">我的2020年新年计划</a></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>还是谢谢这个2019年吧，这一年我23岁，时间过得总是很快，我多想留在这个美好的年纪呀。未来的那个你，我想和你说，岁月很残酷，或许会把你对生活的热情浇灭，但是我希望你能记住23岁的那个你也曾拥有过炙热的心。</p>]]></content>
      
      
      <categories>
          
          <category> 乱七八糟 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从游戏设计到装饰器模式</title>
      <link href="/2019/11/04/%E4%BB%8E%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E5%88%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/11/04/%E4%BB%8E%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E5%88%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本博文碍于作者的学识与见解，难免会有疏漏错误之处，请谅解。<br><br>转载请注明出处: <a href="www.sshenzx.com">www.sshenzx.com</a> 谢谢~</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章主要想讲述一下设计模式中的装饰器模式。其实我是不太敢写关于设计模式的博文的，一是觉得用好设计模式本身就是需要大量经验作为基础，目前的我还欠些火候，二是觉得设计模式作为一种经验之谈，本来就很难描述清楚其精髓，网上查阅的博文大都只是扔了几个类图，放上代码就完事了，但作为读者真的是一脸懵逼…不过呢尽管这样，我也想尝试一下看看自己能不能解释清楚这个东西，也检查下自己究竟掌握了多少。这个系列的博文，我会尽量以一个读者的角度由浅入深的去了解装饰器模式的由来和使用。</p><a id="more"></a><h1 id="为什么要用装饰器模式？"><a href="#为什么要用装饰器模式？" class="headerlink" title="为什么要用装饰器模式？"></a>为什么要用装饰器模式？</h1><h2 id="从某款《传奇》网游的需求开始"><a href="#从某款《传奇》网游的需求开始" class="headerlink" title="从某款《传奇》网游的需求开始"></a>从某款《传奇》网游的需求开始</h2><p>我们今天的主角是一个叫Skrrr的程序员，任职于某著名游戏公司”贪玩红月”，最近公司在研发一款传奇类网游，自然请了众多大牌明星来代言哦。公司的业务是当用户被广告吸(e)引(xin)到之后，马上就能一键注册，瞬间创建自己的游戏人物。职业有战士，刺客，射手等等等，当然每个职业的初始属性是不同的。现在需要Skrrr同学，实现创建游戏角色的功能。</p><p>当然，这个简单的需求自然难不倒skrrr同学，它的设计如下：</p><p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/Decorator_1.jpg" class="lozad"></p><p>这真的很简单，每个职业继承于一个游戏角色的类就行了，以后如果要新增职业那就新建类就好啦，也方便扩展。于是，Skrrr同学看着自己满意的杰作开开心心的回家睡觉了。可是第二天，公司发现单单让用户创建几个职业根本赚不到钱呀，为了让用户体验到氪金的乐趣，让充钱的土豪在出生的时候就赢在起跑线上。于是推出了3种出生套餐，充了99元的用户，出生可以获得一把大剑，充了999的用户出生可以获得金丝软甲，充了9999的用户出生甚至可以获得上古神器——倚天剑……当然这些装备都是有属性加成的，不同的装备加的属性不一样。</p><p>这下Skrrr同学可头大了，没办法只能硬着头皮加班加点完成了这些功能，这一次它的设计如下：</p><p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/Decorator_2.jpg" class="lozad"></p><p>经过了一个晚上的战斗，Skrrr同学根据相应的职业创造出了各式各样的类，虽然很累，但是至少也是完成了，于是Skrrr同学看着自己似乎不是很满意的杰作疲惫的回家睡觉了。结果第二天，Skrrr同学终于发现事情并没有那么简单，噩梦才刚刚开始…原来公司的野心比自己想的还大，只要用户钱到位什么姿势它都会…公司推出了各式各样的出生套餐，什么匕首啊，屠龙刀啊等一堆装备。更夸张的是，当客户充满88888元后解锁多装备成就，左手屠龙刀右手倚天剑，身穿软猬甲，脚踩风火轮不是梦！当这些需求扔到Skrrr同学面前时，他终于崩溃了，增加一件装备就等于给每个职业加一个类，更何况时多件装备的组合,而且未来万一再新增职业，这工作量可是成几何倍的增长啊。</p><p>Skrrr同学这下真没辙了，哪怕加班到猝死，这种变态量的需求也应付不过来呀，那还有什么办法呢？</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>可以发现在上面的设计中，角色和装备这两个东西之间是完全耦合的，当一个装备进行了新增，那么相应的所有角色都要新增一个对应的类。同样的如果一个角色属性发生了修改，那么所有使用装备的该角色都要修改。这就导致了类非常多，同时很难扩展。这种方法其实违反了六大设计设计原则中的“开闭原则”。</p><blockquote><p>开闭原则: 一个软件实体（如类，模块和函数）应该对扩展开放，对修改关闭。</p></blockquote><p>其实在软件开发的过程中，改需求是非常频繁的一件事情。<strong>开闭原则</strong> 则是希望使用扩展的方式来进行改变，而不是修改现有代码的方式进行改变。这样的好处在于大大增加了系统的稳定性以及灵活性，降低代码劣化速度。</p><p>在Skrrr同学的设计里，如果任何一件装备的属性或者角色的属性改变了，那么所有有关它们的类全部都要修改，会导致后期的维护非常繁琐。而在设计之初如果能考虑到这一方面，使用合适的架构来设计类，就能使得角色与装备之间解耦，做到灵活配置。</p><p>当然对于整个软件架构完完全全做到开闭原则是几乎是不可能的，因为想要遵循开闭原则通常要引入一些新的抽象层次，增加代码的复杂度。而我们所要做的应该是在软件规划的时候就提前找到最容易变化的地方，针对性的应用开闭原则。</p><p>以上写了这么多其实就是想说明Skrrr同学遇到的这种困难完全是因为它违反了”开闭原则”而导致的。那么如何解决这个问题，或者说如何让代码遵循“开闭原则”，就可以用到我们今天所要讲的<strong>装饰器模式</strong>了</p><h1 id="装饰器模式的使用"><a href="#装饰器模式的使用" class="headerlink" title="装饰器模式的使用"></a>装饰器模式的使用</h1><blockquote><p>装饰器模式的定义：动态地将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择</p></blockquote><p>其实装饰器模式挺好理解的，顾名思义，就是通过对一个类或者说对象进行装饰，而使得不修改这个类就能达到动态扩展的目的。这种模式会创建一个装饰类，用来包装原有的类，同时该装饰类也同样会保持原有类的类型。它的类图如下：</p><p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/Decorator_3.jpg" class="lozad"></p><p>从类图中可以发现一个很特别的点，装饰器类继承了我们被装饰类的同时又持有了被装饰的类。我个人觉得这就是装饰器模式的精髓，利用了组合+继承的方式实现动态扩展。通过继承的方法继承了被装饰类的类型，但是并没有继承被装饰类的行为，而是通过装饰者和组件组合的方式，重新定义了类的行为。</p><h2 id="利用装饰器实现《传奇》网游的新需求"><a href="#利用装饰器实现《传奇》网游的新需求" class="headerlink" title="利用装饰器实现《传奇》网游的新需求"></a>利用装饰器实现《传奇》网游的新需求</h2><p>Skrrr同学认认真真的了解了装饰器模式后，终于顿悟了。在一个晚上的努力后，这一次它的新设计如下：</p><p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/Decorator_4.jpg" class="lozad"></p><p>使用了装饰器模式之后，装备和角色完全解耦，新增一件装备就直接扩展新的类即可，再也不用处理一堆类了。不仅如此，面对同时要求携带多个装备的需求也相应解决。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li><p>游戏角色的基类AbstractCharacter(被装饰的类)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCharacter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生命值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer hp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 攻击力</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer atk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 防御力</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer def;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 速度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer spd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 职业名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 人物描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>游戏装备类AbstractEquipmentDecorator(装饰类)：</p></li></ul><p>在这里可以看到在装备类中我们要求继承的基类中所有的方法都设置为了Abstract必须要重写。还记得上文所提到的么，装饰类继承被装饰类是为了继承被装饰类的类型，而不是被装饰类的行为。所有的行为都是通过组合的方式去重新定义行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEquipmentDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractCharacter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法必须重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title">getHp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法必须重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title">getAtk</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法必须重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title">getDef</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法必须重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title">getSpd</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法必须重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">describe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>骑士(游戏角色实现类):</li></ul><p>定义了最简的初始属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Knight</span> <span class="keyword">extends</span> <span class="title">AbstractCharacter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Knight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setHp(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">this</span>.setAtk(<span class="number">45</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDef(<span class="number">70</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSpd(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">this</span>.setName(<span class="string">"骑士"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>大剑(游戏装备实现类)</li></ul><p>通过构造方法传参,我们允许让大剑装饰类允许引用一个角色类，这个角色类不一定就是战士/刺客这种角色实现类哦，还有可能也是一件装备(甚至可以用无数个包装类包装一个组件)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sword</span> <span class="keyword">extends</span> <span class="title">AbstractEquipmentDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过组合的方式持有了游戏角色基类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AbstractCharacter character;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sword</span><span class="params">(AbstractCharacter character)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.character = character;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getHp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> character.getHp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在原有角色基础上攻击力+30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAtk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> character.getAtk() + <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在原有角色基础上防御力+5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> character.getDef() + <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSpd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> character.getSpd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将原有角色 携带的所有都打印出来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> character.describe() + <span class="string">" 装备了一把大剑"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><ul><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个持剑带铠甲的刺客</span></span><br><span class="line">        AbstractCharacter assassinWithSwordAndArmor = <span class="keyword">new</span> Assassin();</span><br><span class="line">        assassinWithSwordAndArmor = <span class="keyword">new</span> Sword(assassinWithSwordAndArmor);</span><br><span class="line">        assassinWithSwordAndArmor = <span class="keyword">new</span> Armor(assassinWithSwordAndArmor);</span><br><span class="line"></span><br><span class="line">        System.out.println(assassinWithSwordAndArmor.describe());</span><br><span class="line">        System.out.println(<span class="string">" 攻击力:"</span> + assassinWithSwordAndArmor.getAtk());</span><br><span class="line">        System.out.println(<span class="string">" 防御力:"</span> + assassinWithSwordAndArmor.getDef());</span><br><span class="line">        System.out.println(<span class="string">" 生命值:"</span> + assassinWithSwordAndArmor.getHp());</span><br><span class="line">        System.out.println(<span class="string">" 速度:"</span> + assassinWithSwordAndArmor.getSpd());</span><br><span class="line">        System.out.println(<span class="string">"==================================="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个双剑骑士</span></span><br><span class="line">        AbstractCharacter doubleSwordKnight = <span class="keyword">new</span> Knight();</span><br><span class="line">        doubleSwordKnight = <span class="keyword">new</span> Sword(doubleSwordKnight);</span><br><span class="line">        doubleSwordKnight = <span class="keyword">new</span> Sword(doubleSwordKnight);</span><br><span class="line"></span><br><span class="line">        System.out.println(doubleSwordKnight.describe());</span><br><span class="line">        System.out.println(<span class="string">" 攻击力:"</span> + doubleSwordKnight.getAtk());</span><br><span class="line">        System.out.println(<span class="string">" 防御力:"</span> + doubleSwordKnight.getDef());</span><br><span class="line">        System.out.println(<span class="string">" 生命值:"</span> + doubleSwordKnight.getHp());</span><br><span class="line">        System.out.println(<span class="string">" 速度:"</span> + doubleSwordKnight.getSpd());</span><br><span class="line">        System.out.println(<span class="string">"=================================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打印：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">刺客 装备了一把大剑 装备了一具铠甲</span><br><span class="line"> 攻击力:110</span><br><span class="line"> 防御力:85</span><br><span class="line"> 生命值:70</span><br><span class="line"> 速度:50</span><br><span class="line">===================================</span><br><span class="line">骑士 装备了一把大剑 装备了一把大剑</span><br><span class="line"> 攻击力:105</span><br><span class="line"> 防御力:80</span><br><span class="line"> 生命值:80</span><br><span class="line"> 速度:30</span><br><span class="line">==================================</span><br></pre></td></tr></table></figure><p>至此Skrrr同学完全实现了动态拓展游戏角色和装备。无论是装备还是角色再如何修改与变动，都只要专注于修改它们本身即可。这种方式看起来似乎万无一失，但是不是真的完美呢？</p><h1 id="装饰器模式仍存在的问题"><a href="#装饰器模式仍存在的问题" class="headerlink" title="装饰器模式仍存在的问题"></a>装饰器模式仍存在的问题</h1><p>以上大致介绍了装饰器模式的使用方式。我们可以了解到装饰器模式最大的好处在于使得装饰对象与被装饰对象解耦，使得被修饰的类可以动态拓展。并且他完全符合开闭原则，解决了以前使用继承而导致的类爆炸问题。</p><p>当然所有设计模式都不是完美的，它只适用于特定的情况。装饰器模式自然也有些弊端:</p><ol><li>这种多层修饰会导致类的层次比较复杂会衍生出许多包装类，因此如果只是简单的几个类的扩展的话，完全没必要使用装饰器模式。</li><li>可以动态装饰，但是不能动态的撤销装饰。在上述例子中，虽然每个角色可以动态携带各种装备，但是一旦人物创建完成后，未来想要把某件装备换下就做不到了（想要解决这个问题,可以采用策略模式，未来应该会有介绍）。</li></ol><p>因此不止是装饰器模式，任何设计模式在使用前需要仔细考量需求，判断设计模式是否真的符合当前情况。在合适的地方使用合适的设计模式的确可以大大优化系统架构，但是如果滥用设计模式的话反而会导致系统更加的复杂难懂。当然这种判断力自然是需要经验的累积的，只有踩过了足够的坑才知道什么才是最适合的。</p><h1 id="JDK中的装饰器模式"><a href="#JDK中的装饰器模式" class="headerlink" title="JDK中的装饰器模式"></a>JDK中的装饰器模式</h1><p>JDK中其实也运用了许许多多精巧的设计模式。装饰器模式自然也有，最经典的就是Java的IO流。IO流中分为了节点流与处理流,节点流如：FileInputStream,ByteArrayInputStream。处理流如：BufferedInputStream,DataInputStream。其中节点流其实就是被装饰的对象，而处理流则是基于节点流的装饰对象。其类图如下：</p><p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/Decorator_5.jpg" class="lozad"></p><p>可以看到所有的处理流类都继承于FilterInputStream的抽象包装类，类似于例子中的装备类。而所有节点流都直接继承InputStream的基类，类似于例子中的角色类。当然正是应用了装饰器模式，所以导致Java.io包的各种流特别多，造成了一定的复杂度，当然为了好的扩展性，这种设计模式是利大于弊的。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天所介绍的是设计模式之——装饰器模式。洗完后其实感觉这篇文章思路并不是特别清晰,同时也碍于自己的水平设计模式这一块的分析并不是特别到位，以后说不定还会有所修改吧。那简单介绍下我个人认为装饰器模式的几个要点：</p><ol><li>装饰器模式通过继承+组合的方式在动态拓展类的行为的同时，仍保留了原有类的类型。</li><li>可以用无数个装饰类包装一个组件。</li><li>装饰器模式符合“开闭原则”,即对拓展开放，对修改关闭。</li><li>不要滥用装饰器模式，使用装饰器模式会产生许多小的包装类，需要合理选择。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《HeadFirst设计模式(中文版)》</p>]]></content>
      
      
      <categories>
          
          <category> 死磕设计模式系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探究JDK1.8中HashMap的实现原理</title>
      <link href="/2019/10/19/%E6%8E%A2%E7%A9%B6JDK8%E4%B8%ADHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2019/10/19/%E6%8E%A2%E7%A9%B6JDK8%E4%B8%ADHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本博文碍于作者的学识与见解，难免会有疏漏错误之处，请谅解。<br><br>转载请注明出处: <a href="www.sshenzx.com">www.sshenzx.com</a> 谢谢~</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总结了一个月的面试经验(其实也就3场面试…)，HashMap这个点基本上是必被问到的，因此想再看一遍HashMap的源码，对其底层加深一下印象。作为我的第一篇正式博客同时也知道没几个人会看这个博客，我就不说什么欢迎指正的客套话了，爱咋咋地。</p><p>(注：本文所述的HashMap以及代码都是基于JDK1.8的，与之前的版本区别较大，需要注意)</p><h1 id="什么是HashMap？"><a href="#什么是HashMap？" class="headerlink" title="什么是HashMap？"></a>什么是HashMap？</h1><p>HashMap本质当然是Map，是一个存储Key-Value键值对的数据结构。由于它会对每个Key进行hash运算存储其定位，因此它的查询以及插入效率非常高。在理想状态下时间复杂度为O(1)，最差情况下时间复杂度为O(n)。但同时它也是线程不安全的，如果想要使用线程安全的HashMap建议使用ConcurrentHashMap。</p><a id="more"></a><h1 id="HashMap的内部结构"><a href="#HashMap的内部结构" class="headerlink" title="HashMap的内部结构"></a>HashMap的内部结构</h1><p>HashMap的本质是一个链表+数组的数据结构。（JDK1.8还增加了红黑树的结构） 其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//主要存储数据的对象 table</span></span><br><span class="line">  <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Node类</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//算出的hash值，用来定义数组索引的位置</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="comment">//key值</span></span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  <span class="comment">//value值</span></span><br><span class="line">  V value;</span><br><span class="line">  <span class="comment">//指向下一个Node对象</span></span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//get set方法</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码我们可以看到Node类作为HashMap的静态内部类，本身实现了Map.Entry,它是真正用来存储键值对的，同时他也是一个链表。而HashMap内部维护了一个Node数组名为table的变量，也被称为哈希桶，是HashMap的核心，各项操作都围绕它展开。他的整个内部图如下：</p><p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/HashMap_5.jpg" class="lozad"></p><p>HashMap还有几个比较重要的成员变量，在了解其原理之前我们必须先认识他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//HashMap目前保存键值对数量(也就是大小)</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录HashMap内部结构发生变化的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所能容纳的键值对极限</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p><strong>size</strong><br>和其他容器的size一样，代表着目前HashMap存放的键值对数量</p><p><strong>threshold</strong><br>代表HashMap能容纳键值对的个数极限，如果一旦超过这个极限HashMap就会进行相应的扩容。</p><p><strong>loadFactor</strong><br>是负载因子，它也会影响到threhold的变化：threshold = length * loadFactor 。这里的<br><strong>length</strong><br>也就是table数组的大小 ，默认值给的是16，值得注意的是它的值永远是2的n次方，这是HashMap做的一个优化点，也是面试经常问的，后续会讲明其原因。从上面这个公式可以看出，loadFactor越小，threshold也会越小，会导致扩容频率变高，容易造成空间浪费。loadFactor越大，threshold也会越大，扩容频率变小，但会增大Hash冲突的机率，耗时更久(这一块目前不理解没关系，后面会讲解)。因此loadFactor的大小填写，是需要我们再时间复杂度与空间复杂度之间权衡的，系统默认值给的是0.75，符合大部分情况，一般不建议修改。</p><p><strong>modCount</strong><br>字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对时modCount会加一，但是某个key对应的value值被覆盖不属于结构变化所以modCount不会变化。</p><h1 id="HashMap-源码解析"><a href="#HashMap-源码解析" class="headerlink" title="HashMap 源码解析"></a>HashMap 源码解析</h1><p>对HashMap有一定的了解后，我们终于可以开始手撕源码啦。我们首先就从put方法进入开始看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  key值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果key对应的value已经存在，是否覆盖value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为false表示处于创建状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回key对应的上一个value数据，如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">                 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到put方法本身内部又调用了putVal，它有五个入参，在注解上我也已经写了，<br>它们分别代表：</p><ol><li>hash：key的hash值</li><li>key： key值</li><li>value: value值</li><li>onlyIfAbsent：如果key对应的value已经存在，是否覆盖value值</li><li>evict：如果为false表示处于创建状态，仅仅为LinkedHashMap方便排序操作，HashMap中可以忽略</li></ol><p>针对于onlyIfAbsent为true，很明显我们的HashMap如果key已经对应存在对应value映射，在put时会覆盖掉原来的值，想不覆盖的话可以调用putIfAbsent()方法。</p><p>有一个重点其实是在方法hash(key)上，这个方法计算出了key的hash值，他是HashMap的精华所在，也是面试中常问的一个考点。接下来我们将重点说明下这个方法以及如何使用这个hash值</p><h2 id="hash-方法以及确定哈希桶数组索引位置"><a href="#hash-方法以及确定哈希桶数组索引位置" class="headerlink" title="hash()方法以及确定哈希桶数组索引位置"></a>hash()方法以及确定哈希桶数组索引位置</h2><p>hash()方法其实顾名思义就是用来获取key的hash的一个hash值的,但是HashMap里的hash()方法似乎与一般的直接key.hashCode()不太一样，我们先看看它到底是什么样的神奇操作。<br>其源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>歪果仁的代码追求精简，虽然就两行，但是看起来还是蛮恶心的，但是还是可以看出来如果key为空，那么hash值就默认问0，这也就说明HashMap的key是可以为空的，而我们也知道HashTable的key不能为空。如果不为空则会执行后面一长串，这一长串可以分步骤看</p><ol><li>h = key.hashCode() 获取了key的hashCode值</li><li>h^h&gt;&gt;&gt;16   将hashCode的值异或他的高16位获取到hash值</li></ol><p>我们知道hashCode本身是一个32位的int类型，进行这样的操作就等于将hashCode的高16位异或它的低16位得到一个新的hash值。</p><p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/HashMap_1.jpg" class="lozad"></p><p>但是拿到这样一个hash值的作用是什么呢？我们可以先想一下如何利用key的hash值确定每个key的哈希桶索引位置而且还需要尽量均衡。第一个想到的当然是用hash值对哈希桶的长度(length)进行取模的操作。(当然我本人是连这种方式都想不到的= =)即:</p><p> <strong>index = hash % length</strong></p><p>这种方式可以用随机的hash值算出随机的索引并且分配也尽量均匀。没错！!HashMap也是这么想的。但是这种取模运算本身是对CPU运算开销比较大的，为了优化速度，HashMap采取了更优雅的方式，在putVal的核心代码里可以看到这么一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*为了方便理解,代码有改动+精简,但是整体思路没变</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;            </span><br><span class="line">                    <span class="comment">//table就是HashMap的table即哈希桶</span></span><br><span class="line">                    Node&lt;K,V&gt;[] tab = table;    </span><br><span class="line">                    <span class="comment">//哈希桶的长度</span></span><br><span class="line">                    <span class="keyword">int</span> length = tab.length;  </span><br><span class="line">                    <span class="comment">//确定索引的位置</span></span><br><span class="line">                    <span class="keyword">int</span> index = (length-<span class="number">1</span>) &amp; hash;       </span><br><span class="line">                    <span class="comment">//索引的值</span></span><br><span class="line">                    Node&lt;K,V&gt; p = tab[index];</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到HashMap采用了hash值”与”length-1的方式来确定索引位置。即：</p><p> <strong>index = hash &amp; length-1</strong></p><p>还记得之前我们说过hashTable的length总是2的n次方吗？这个是故意为了加快取模运算而设计的。当length的长度为2的n次方时hash值对length取模或者”与”上length-1得到的效果是一样的，但是”与”操作相比取模速度能快很多。<br>而之所以hash值要用拿hashcode的高16位异或低16位的原因根据官方的解释是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/HashMap_2.jpg" class="lozad"></p><p><font color="red"><b>小Tips:</b></font></p><p>hash()方法中的高16位异或16位的计算方式，是在JDK1.8之后才加上的，在JDK1.7及之前的版本里是indexFor()方法，直接用hashCode&amp;length-1计算出索引位置。如果面试官有问HashMap的JDK1.7与JDK1.8的区别可不要忘记说了哦<br></p><h2 id="putVal-方法解析"><a href="#putVal-方法解析" class="headerlink" title="putVal()方法解析"></a>putVal()方法解析</h2><p>了解了如何确定哈希桶的索引地址后我们终于可以来看看核心操作方法putVal了，不多说直接撕源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  key值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果key对应的value已经存在，是否覆盖value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为false表示处于创建状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回key对应的上一个value数据，如果没有就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果发现哈希桶为空或者长度为0，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定哈希桶的索引位置，如果里面目前没有数据，则直接插入新Node进去</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有数据，即发生hash冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果新插入数据的key与发生冲突的Node的key值相同，则记录下来</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果冲突的Node已经是红黑树结构了，则调用树的插入方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是链表则开始遍历链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//整个链表遍历完成后仍未发现key值相同的数据,则在链表结尾插入数据</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//插入数据后，发现链表数量已经到达一定长度后链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//发现新插入的key值与链表已存在的数据key值相同，则记录下来</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有替换原有数据，则将新值替换旧值并返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">//如果onlyIfAbsent为true就不替换了</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//方便linkedHashMap排序操作，HashMap里可无视</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//modCount+1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果新加如元素后发现键值对超过所能容纳的键值对极限则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();        </span><br><span class="line">      <span class="comment">//方便linkedHashMap排序操作，HashMap里可无视    </span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码我们可以大致理出putVal的操作流程</p><ol><li>判断哈希桶大小，如果为空则进行第一次的扩容</li><li>计算索引位置index，如果哈希桶索引位置table[index]没有数据则插入数据新数据，并判断键值对数量是否超过了threshHold，超过了则进行扩容。</li><li>如果table[index]有数据即发生hash冲突，判断table[index]的key值是否与插入的数据相同，如果相同则使用新的数据覆盖原有数据并返回原有数据，否则继续。</li><li>判断table[index]是否为为红黑树，如果是的话则直接在红黑树中插入数据，否则则继续</li><li>遍历链表tabe[i],如果存在key相等的数据则覆盖原有数据，并返回原有数据。如果不存在key相等的数据则在链表末尾插入新数据，同时判断链表长度是否到达可以转换红黑树的标准(默认长度为8)，到达的话则进行转换。</li></ol><p>具体流程如图如下所示：</p><p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/HashMap_3.jpg" class="lozad"></p><p><font color="red"><b>小Tips:</b></font></p><p>链表长度大于8转换成红黑树的操作是在JDK1.8中新加的，目的是当出现大量Hash冲突时也能使用红黑树让查找的时间复杂度由O(n)降低为O(logn)。至于红黑树里面添加数据的源码我就不手撕了，确实比较复杂，我撕不动…知道红黑树是一颗特殊的二叉平衡查找树即可。<br></p><h2 id="resize-方法解析"><a href="#resize-方法解析" class="headerlink" title="resize()方法解析"></a>resize()方法解析</h2><p>在前面的介绍里我们可以注意到，在插入新数据以及首次插入数据时，HashMap都进行了一次判断是否需要扩容。我们知道Java中数组的长度是固定的，当我们需要扩容时，肯定需要用一个新的数组来替换老的数组，并将数据迁移过去。而这些操作在HashMap中全部体现在resize()方法中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//----------------------以下为第一部分，负责初始化定义新容器大小与threshold-----------------------------------</span></span><br><span class="line">    <span class="comment">//获取旧的table，旧的threshhold，旧的长度</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//如果容器容量已经到达最大值，则不再扩容了，threshhold也设置为最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义了新容器大小为旧容器大小的两倍，新threshold也为旧threshhold两倍</span></span><br><span class="line">        <span class="comment">//注意这里采用了 &lt;&lt; 1操作即地位补0的方式，与 *2 的效果一样且速度更快</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果hashtable尚未定义，则初始化定义容量以及threshold</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">       <span class="comment">//生成新的newTab来替换之前的oldTable</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">   <span class="comment">//-------------------------------------------------------------------------------------------------------</span></span><br><span class="line">   <span class="comment">//-----------------------------以下为第二部分，负责将oldTab的数据导入到newTab中------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历oldTab</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">//如果oldTab[j]只有一个Node，那么直接重新计算index，将Node放入</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="comment">//如果oldTab[j]已经转换为一个红黑树，则对红黑树进行rehash</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//对于链表进行操作</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//计算链表oldTab[j]新的索引值，如果索引不需要更改，则由loHead链表保存它们</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//计算链表oldTab[j]新的索引值，如果索引需要更改，则由hiHead链表保存它们</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//循环结束。如果不需要改变索引位置的Node则直接将loHead保存在newTab[j]中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果需要改变索引位置的Node则直接将hiHead保存在newTab[j]中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容代码是非常精巧的，虽然看起来比较复杂，但是如果去细究的话就会发现里面用了很聪明的优化方式。我们可以将代码分为两部分去看(已用注解区分)</p><p><strong>第一部分：初始化新容器</strong></p><p>前面我们说了，扩容肯定是需要用一个新的哈希桶来替换旧的哈希桶的。那么HashMap里面由于为了优化取模速度(上文已提及)，让哈希桶的长度必须为2的n次方，所以每一次扩容只需要将原有哈希桶的大小扩充一倍即可。于是我们就可以看到newCap = oldCap &lt;&lt; 1，这种通过位偏移的方式相对于使用newCap = oldCap * 2的方式效率会更高，也算设计团队的一个优化地方。同时我们在代码里也能看到，如果哈希桶的容器仍未定义即第一次使用时，也会进行数据初始化，这一部分很简单就不再叙述了。</p><p><strong>第二部分：将旧哈希桶的数据导入到新哈希桶中</strong></p><p>这一部分讲道理思路其实也很简单。在JDK1.7中的实现方式是遍历旧哈希桶中的所有Node(rehash)，重新计算它们的索引位置，依次放入到新的哈希桶中。(值得注意的是JDK1.7中旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，感兴趣的去看JDK1.7的源码就能明白其中意思了)而在JDK1.8中，HashMap采用了一种更聪明的方式。由于哈希桶的长度一定是2的n次方，所以对Node的重新计算索引也就是hash值对length-1重新取模的索引值，要么是原索引的值，要么是原索引+原length的值。可能比较绕，看下图就明白了，n为table的长度，图(a)表示扩容前的key1和key2两种key确定索引位置的示例，图(b)表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img alt data-src="https://raw.githubusercontent.com/glass36/BlogFiles/master/images/HashMap_4.jpg" class="lozad"></p><p>我们会发现确定索引值是否要变化的关键，其实在于hash值新增的那一位bit，如果那一位为0，则新的索引位置就是原索引位置，如果那一位为1，则新的索引位置就是原索引位置+oldLength。所以我们重新计算索引时根本不需要重新计算它们的位置，只需要判断新增的那一位bit是0还是1就可以了，大大优化了效率。因此我们再源码中可以看到对 (e.hash &amp; oldCap) == 0 进行了判断，如果为true代表索引为原位置，如果为false代表索引为原位置+oldLength。同时我们也可以发现在代码段中定义了loHead与hiHead两个链表，一个是存放不用变更索引位置的Node，一个是存放变更索引位置的Node。定义这两个链表使得变更新索引位置的链表不会像JDK1.7一样倒置。</p><h2 id="get-，remove-等方法的思路"><a href="#get-，remove-等方法的思路" class="headerlink" title="get()，remove()等方法的思路"></a>get()，remove()等方法的思路</h2><p>至此我们已经基本了解完了HashMap的put方法的流程。当然HashMap也提供了get()，remove()等方法，但是大致思路与put是基本一致的。都是要通过计算key的hash值确定，哈希桶的位置，然后判断是否有哈希冲突的情况，如果有的话再判断是链表还是红黑树，最终确定到对应的值。具体的流程都是一样的，再次就不赘述了，可以自己跟着源码看下去。</p><h1 id="HashMap的线程安全问题"><a href="#HashMap的线程安全问题" class="headerlink" title="HashMap的线程安全问题"></a>HashMap的线程安全问题</h1><p>开始的时候我们就已经提到HashMap是线程不安全的，那么为什么说HashMap是线程不安全的呢？ 在JDK1.7中，resize时更新到新的索引位置时采用的是头插法的方法，会让链表导致。但是在多线程的情况下头插法会出现链表回环的情况(解释比较复杂，就不详细说明了)。在JDK1.8中，我们已经取消了这种方式，但仍然会出现线程不安全的情况。如putVal中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已省略大量代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     ...</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">//确定哈希桶的索引位置，如果里面目前没有数据，则直接插入新Node进去</span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">     tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     ...</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在putVal中如果线程A与线程B同时进入了该方法，同时判断了(p = tab[i = (n - 1) &amp; hash]) == null 为true，这样会导致其中一个插入的数据会被丢失的情况出现。</p><p>其实HashMap使用了公用的变量Node[]table进行各类复杂的操作，是肯定会出现线程不安全的情况的，所以使用的时候一定要注意。当然也不是没有解决方案，最早方法自然就是使用HashTable，但是众所周知HashTable的效率很低，它对每个操作都加了锁。这里推荐使用java.util.concurrent包下的ConcurrentHashMap，它使用了分段锁的方式细化锁的粒度，在保证了线程安全的同时也不比HashMap慢多少(ConcurrentHashMap也是面试常问的点，后续有时间也一定会专门写一篇对其原理的分析)。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>那在最后来总结下我个人认为的HashMap的精髓</p><ol><li>HashMap的是一个链表+数组+红黑树的存储结构</li><li>确定哈希桶位置使用了 hash &amp; length-1 的方式显著提高了效率</li><li>JDK1.8中，链表长度超过8将会自动转换为红黑树，提高了查找效率</li><li>HashMap是线程不安全的，想要线程安全请使用ConcurrentHashMap</li></ol><br><br><p><strong>小结后的小小结：</strong></p><p>终于完成了我的第一篇正式博文。突然发现写博客真的是一个很累的事情啊！！！为了这篇博文，看源码看资料写博文这一系列操作花费了我大概有10个小时，不过对我自己也有了一个很大的提升，不管怎么说算是一个好的开始？哈哈哈，希望能坚持下去吧。over！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">美团技术博客——Java 8系列之重新认识HashMap</a> [图片素材来源]</p><p><a href="https://www.cnblogs.com/qingyunzong/p/9143249.html" target="_blank" rel="noopener">漫画：高并发下的HashMap</a></p>]]></content>
      
      
      <categories>
          
          <category> Java学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那就写在开始吧</title>
      <link href="/2019/10/13/%E9%82%A3%E5%B0%B1%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B%E5%90%A7/"/>
      <url>/2019/10/13/%E9%82%A3%E5%B0%B1%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B%E5%90%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="来自灵魂的四个追问"><a href="#来自灵魂的四个追问" class="headerlink" title="来自灵魂的四个追问"></a>来自灵魂的四个追问</h1><h2 id="问：你是谁呀？"><a href="#问：你是谁呀？" class="headerlink" title="问：你是谁呀？"></a>问：你是谁呀？</h2><p>答：我是一名毕业于双非末流大学，没啥毅力，没啥能力,有点强迫症,喜欢折腾一些奇奇怪怪的东西的程序猿？</p><h2 id="问：你这个博客想记录什么？"><a href="#问：你这个博客想记录什么？" class="headerlink" title="问：你这个博客想记录什么？"></a>问：你这个博客想记录什么？</h2><p>答：em….其实我还没想好，应该主要就是一些技术有关的帖子吧，把平日里解决问题的方法，以及一些总结的一些技术贴记录下来。当然也可能神经兮兮的写几篇矫情的文章？反正我这个博客估计到死也没人会来看，我想写的主要都是给自己看的，估计多年后的我看到年轻时的自己写的这堆不专业的东西会笑出声吧哈哈哈。</p><a id="more"></a><h2 id="问：你为什么想要开始写博客？"><a href="#问：你为什么想要开始写博客？" class="headerlink" title="问：你为什么想要开始写博客？"></a>问：你为什么想要开始写博客？</h2><p>答：前段时间为了应付面试，做出了不少的努力。虽然没有进大厂，但好歹进了一个不算太差的互联网公司？这期间对整套Java程序员应该有的技术栈有了一定的了解，也发现学到的新东西，如果不把它表述出来，其实根本不是自己的，复盘学习非常重要！因此打算把前段时间写的笔记再整理下，记录到博客上。未来的话，如果有新学的东西或者遇到的问题，我也会记录下来。当然，听说写博客，对简历还蛮加分的哈哈。所以未来的Hr，如果你看到这个人写的这段话，就把他招进来吧，毕竟他还蛮努力的= =</p><h2 id="问：你会坚持下来吗？"><a href="#问：你会坚持下来吗？" class="headerlink" title="问：你会坚持下来吗？"></a>问：你会坚持下来吗？</h2><p>答：其实我觉得能坚持写博客的人都很厉害。这是一个很考验人的事情，我当然希望我是一个很厉害的人，虽然我的这个博客可能更新的不会太勤，但是会尽力坚持下来。先定个小目标，一周一篇？算了，还是一个月一篇吧。。。</p><hr><br><br><br><br><br><br><br><font face="黑体" color="red" size="1">我知道我是一个平凡的人，但我也知道我想要什么并会为之努力。<br>希望多年后的我能配得上自己的野心，也不会辜负自己所受的苦难吧。<br>(矫情的话都偷偷写在最后)</font>]]></content>
      
      
      <categories>
          
          <category> 乱七八糟 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
